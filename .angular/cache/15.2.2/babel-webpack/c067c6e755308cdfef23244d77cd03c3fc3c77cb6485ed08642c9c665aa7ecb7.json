{"ast":null,"code":"import _asyncToGenerator from \"E:/work/pigallery2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ToastrService } from 'ngx-toastr';\nimport { NetworkService } from './network/network.service';\nimport { AuthenticationService } from './network/authentication.service';\nimport { NotificationType } from '../../../common/entities/NotificationDTO';\nimport { UserRoles } from '../../../common/entities/UserDTO';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"ngx-toastr\";\nimport * as i2 from \"./network/network.service\";\nimport * as i3 from \"./network/authentication.service\";\nexport let NotificationService = /*#__PURE__*/(() => {\n  class NotificationService {\n    constructor(toastr, networkService, authService) {\n      this.toastr = toastr;\n      this.networkService = networkService;\n      this.authService = authService;\n      this.options = {\n        positionClass: 'toast-top-center',\n        animate: 'flyLeft'\n      };\n      this.countedNotifications = [];\n      this.numberOfNotifications = 0;\n      this.lastUser = null;\n      this.authService.user.subscribe(() => {\n        if (this.authService.isAuthenticated() && (!this.lastUser || this.lastUser.id !== this.authService.user.value.id) && this.authService.user.value.role >= UserRoles.Guest) {\n          this.getServerNotifications();\n        }\n        this.lastUser = this.authService.user.value;\n      });\n    }\n    get Toastr() {\n      return this.toastr;\n    }\n    groupNotifications(notifications) {\n      const groups = {};\n      notifications.forEach(n => {\n        let key = n.message;\n        if (n.details) {\n          key += JSON.stringify(n.details);\n        }\n        groups[key] = groups[key] || {\n          notification: n,\n          count: 0\n        };\n        groups[key].count++;\n      });\n      this.numberOfNotifications = notifications.length;\n      this.countedNotifications = [];\n      for (const key of Object.keys(groups)) {\n        groups[key].notification.count = groups[key].count;\n        this.countedNotifications.push(groups[key].notification);\n      }\n    }\n    getServerNotifications() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        try {\n          _this.groupNotifications((yield _this.networkService.getJson('/notifications')) || []);\n          _this.countedNotifications.forEach(noti => {\n            let msg = '(' + noti.count + ') ' + noti.message;\n            if (noti.details) {\n              msg += ' Details: ' + JSON.stringify(noti.details);\n            }\n            switch (noti.type) {\n              case NotificationType.error:\n                _this.error(msg, $localize`Server error`);\n                break;\n              case NotificationType.warning:\n                _this.warning(msg, $localize`Server error`);\n                break;\n              case NotificationType.info:\n                _this.info(msg, $localize`Server info`);\n                break;\n            }\n          });\n        } catch (e) {\n          console.error(e);\n        }\n      })();\n    }\n    success(text, title = null) {\n      this.toastr.success(text, title, this.options);\n    }\n    error(text, title) {\n      this.toastr.error(text, title, this.options);\n    }\n    warning(text, title) {\n      this.toastr.warning(text, title, this.options);\n    }\n    info(text, title = null) {\n      this.toastr.info(text, title, this.options);\n    }\n  }\n  NotificationService.ɵfac = function NotificationService_Factory(t) {\n    return new (t || NotificationService)(i0.ɵɵinject(i1.ToastrService), i0.ɵɵinject(i2.NetworkService), i0.ɵɵinject(i3.AuthenticationService));\n  };\n  NotificationService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: NotificationService,\n    factory: NotificationService.ɵfac\n  });\n  return NotificationService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}