{"ast":null,"code":"import _asyncToGenerator from \"E:/work/pigallery2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ElementRef } from '@angular/core';\nimport { FullScreenService } from '../../fullscreen.service';\nimport { ThumbnailManagerService } from '../../thumbnailManager.service';\nimport { MediaIcon } from '../../MediaIcon';\nimport { Media } from '../../Media';\nimport { PageHelper } from '../../../../model/page.helper';\nimport { Utils } from '../../../../../../common/Utils';\nimport { Config } from '../../../../../../common/config/public/Config';\nimport { MapService } from '../map.service';\nimport { control, divIcon, icon, latLng, latLngBounds, layerGroup, marker, markerClusterGroup, Point, polyline, tileLayer } from 'leaflet';\nimport { ThemeService } from '../../../../model/theme.service';\nimport { MarkerFactory } from '../MarkerFactory';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../fullscreen.service\";\nimport * as i2 from \"../../thumbnailManager.service\";\nimport * as i3 from \"../map.service\";\nimport * as i4 from \"../../../../model/theme.service\";\nimport * as i5 from \"@angular/common\";\nimport * as i6 from \"@asymmetrik/ngx-leaflet\";\nconst _c0 = [\"root\"];\nfunction GalleryMapLightboxComponent_div_4_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵlistener(\"click\", function GalleryMapLightboxComponent_div_4_span_3_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r4.fullScreenService.exitFullScreen());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction GalleryMapLightboxComponent_div_4_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 11);\n    i0.ɵɵlistener(\"click\", function GalleryMapLightboxComponent_div_4_span_5_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext(2);\n      const _r0 = i0.ɵɵreference(1);\n      return i0.ɵɵresetView(ctx_r6.fullScreenService.showFullScreen(_r0));\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction GalleryMapLightboxComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 5)(1, \"div\", 6)(2, \"span\");\n    i0.ɵɵtemplate(3, GalleryMapLightboxComponent_div_4_span_3_Template, 1, 0, \"span\", 7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"span\");\n    i0.ɵɵtemplate(5, GalleryMapLightboxComponent_div_4_span_5_Template, 1, 0, \"span\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(6, \"span\")(7, \"span\", 9);\n    i0.ɵɵlistener(\"click\", function GalleryMapLightboxComponent_div_4_Template_span_click_7_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.hide());\n    });\n    i0.ɵɵelementEnd()()()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.fullScreenService.isFullScreenEnabled());\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r1.fullScreenService.isFullScreenEnabled());\n  }\n}\nexport let GalleryMapLightboxComponent = /*#__PURE__*/(() => {\n  class GalleryMapLightboxComponent {\n    constructor(fullScreenService, thumbnailService, mapService, themeService) {\n      this.fullScreenService = fullScreenService;\n      this.thumbnailService = thumbnailService;\n      this.mapService = mapService;\n      this.themeService = themeService;\n      this.lightboxDimension = {\n        top: 0,\n        left: 0,\n        width: 0,\n        height: 0\n      };\n      this.mapDimension = {\n        top: 0,\n        left: 0,\n        width: 0,\n        height: 0\n      };\n      this.visible = false;\n      this.controllersVisible = false;\n      this.opacity = 1.0;\n      this.mapOptions = {\n        zoom: 2,\n        // setting max zoom is needed to MarkerCluster https://github.com/Leaflet/Leaflet.markercluster/issues/611\n        maxZoom: 2,\n        center: latLng(0, 0)\n      };\n      this.smallIconSize = new Point(Config.Media.Thumbnail.iconSize * 0.75, Config.Media.Thumbnail.iconSize * 0.75);\n      this.iconSize = new Point(Config.Media.Thumbnail.iconSize, Config.Media.Thumbnail.iconSize);\n      this.usedIconSize = this.iconSize;\n      this.mapLayersControlOption = {\n        baseLayers: {},\n        overlays: {\n          Photos: markerClusterGroup({\n            maxClusterRadius: 20,\n            iconCreateFunction: cluster => {\n              const childCount = cluster.getChildCount();\n              let size;\n              let c = ' marker-cluster-';\n              if (childCount < 10) {\n                c += 'small';\n                size = 30;\n              } else if (childCount < 100) {\n                c += 'medium';\n                size = 40;\n              } else {\n                c += 'large';\n                size = 50;\n              }\n              return divIcon({\n                html: '<div><span>' + childCount + '</span></div>',\n                className: 'marker-cluster' + c,\n                iconSize: new Point(size, size)\n              });\n            }\n          })\n        }\n      };\n      // ordered list\n      this.pathLayersConfigOrdered = [];\n      this.thumbnailsOnLoad = [];\n      this.startPosition = null;\n      this.selectBaseLayer = () => {\n        if (!this.leafletMap) {\n          return;\n        }\n        if (this.leafletMap.hasLayer(this.defLayer) && this.themeService.darkMode.value) {\n          this.leafletMap.removeLayer(this.defLayer);\n          this.leafletMap.addLayer(this.darkLayer);\n        }\n        if (this.leafletMap.hasLayer(this.darkLayer) && !this.themeService.darkMode.value) {\n          this.leafletMap.removeLayer(this.darkLayer);\n          this.leafletMap.addLayer(this.defLayer);\n        }\n      };\n      this.setUpPathLayers();\n      this.mapOptions.layers = [this.mapLayersControlOption.overlays.Photos];\n      this.pathLayersConfigOrdered.forEach(pl => this.mapOptions.layers.push(pl.layer));\n      for (let i = 0; i < mapService.Layers.length; ++i) {\n        const l = mapService.Layers[i];\n        const tl = tileLayer(l.url, {\n          attribution: mapService.Attributions\n        });\n        if (l.url === mapService.MapLayer.url) {\n          this.defLayer = tl;\n        }\n        if (l.url === mapService.DarkMapLayer.url) {\n          this.darkLayer = tl;\n        }\n        this.mapLayersControlOption.baseLayers[l.name] = tl;\n      }\n      if (!this.defLayer || !this.darkLayer) {\n        throw new Error('Cant find default or dark layer');\n      }\n      this.mapOptions.layers.push(this.themeService.darkMode.value ? this.darkLayer : this.defLayer);\n      this.mapLayerControl = control.layers(this.mapLayersControlOption.baseLayers, this.mapLayersControlOption.overlays, {\n        position: 'bottomright'\n      });\n      // update map theme on dark theme\n      this.darkModeSubscription = this.themeService.darkMode.subscribe(this.selectBaseLayer);\n    }\n    setUpPathLayers() {\n      Config.Map.MapPathGroupConfig.forEach((conf, i) => {\n        let nameI18n = conf.name;\n        switch (conf.name) {\n          case 'Sport':\n            nameI18n = $localize`Sport`;\n            break;\n          case 'Transportation':\n            nameI18n = $localize`Transportation`;\n            break;\n          case 'Other paths':\n            nameI18n = $localize`Other paths`;\n            break;\n        }\n        const pl = {\n          name: nameI18n,\n          layer: layerGroup([]),\n          themes: conf.matchers.map(ths => {\n            return {\n              matchers: ths.matchers.map(s => new RegExp(s, 'i')),\n              theme: ths.theme,\n              icon: MarkerFactory.getSvgIcon({\n                color: ths.theme.color,\n                svgPath: ths.theme.svgIcon?.path,\n                viewBox: ths.theme.svgIcon?.viewBox\n              })\n            };\n          })\n        };\n        this.pathLayersConfigOrdered.push(pl);\n      });\n      if (this.pathLayersConfigOrdered.length === 0) {\n        this.pathLayersConfigOrdered.push({\n          name: $localize`Other paths`,\n          layer: layerGroup([])\n        });\n      }\n      this.pathLayersConfigOrdered.forEach(pl => {\n        this.mapLayersControlOption.overlays[pl.name] = pl.layer;\n      });\n    }\n    ngOnDestroy() {\n      this.darkModeSubscription.unsubscribe();\n    }\n    static getScreenWidth() {\n      return window.innerWidth;\n    }\n    static getScreenHeight() {\n      return window.innerHeight;\n    }\n    ngOnChanges() {\n      if (this.visible === false) {\n        return;\n      }\n      this.showImages();\n    }\n    onResize() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        _this.lightboxDimension = {\n          top: 0,\n          left: 0,\n          width: GalleryMapLightboxComponent.getScreenWidth(),\n          height: GalleryMapLightboxComponent.getScreenHeight()\n        };\n        _this.mapDimension = {\n          top: 0,\n          left: 0,\n          width: GalleryMapLightboxComponent.getScreenWidth(),\n          height: GalleryMapLightboxComponent.getScreenHeight()\n        };\n        yield Utils.wait(0);\n        _this.leafletMap.invalidateSize();\n      })();\n    }\n    show(position) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        _this2.clearMap();\n        _this2.visible = true;\n        _this2.opacity = 1.0;\n        _this2.startPosition = position;\n        _this2.lightboxDimension = Utils.clone(position);\n        _this2.lightboxDimension.top -= PageHelper.ScrollY;\n        _this2.mapDimension = {\n          top: 0,\n          left: 0,\n          width: GalleryMapLightboxComponent.getScreenWidth(),\n          height: GalleryMapLightboxComponent.getScreenHeight()\n        };\n        _this2.showImages();\n        //  this.centerMap();\n        PageHelper.hideScrollY();\n        yield Utils.wait(0);\n        _this2.lightboxDimension = {\n          top: 0,\n          left: 0,\n          width: GalleryMapLightboxComponent.getScreenWidth(),\n          height: GalleryMapLightboxComponent.getScreenHeight()\n        };\n        yield Utils.wait(350);\n        _this2.leafletMap.invalidateSize();\n        _this2.centerMap();\n        _this2.controllersVisible = true;\n      })();\n    }\n    hide() {\n      this.fullScreenService.exitFullScreen();\n      this.controllersVisible = false;\n      const to = this.startPosition;\n      // if target image out of screen -> scroll to there\n      if (PageHelper.ScrollY > to.top || PageHelper.ScrollY + GalleryMapLightboxComponent.getScreenHeight() < to.top) {\n        PageHelper.ScrollY = to.top;\n      }\n      this.lightboxDimension = this.startPosition;\n      this.lightboxDimension.top -= PageHelper.ScrollY;\n      PageHelper.showScrollY();\n      this.opacity = 0.0;\n      setTimeout(() => {\n        this.visible = false;\n        this.clearMap();\n        this.leafletMap.setZoom(2);\n      }, 500);\n    }\n    showImages() {\n      this.clearImages();\n      // make sure to enable photos layers when opening map\n      if (this.leafletMap && !this.leafletMap.hasLayer(this.mapLayersControlOption.overlays.Photos)) {\n        this.leafletMap.addLayer(this.mapLayersControlOption.overlays.Photos);\n      }\n      this.thumbnailsOnLoad = [];\n      this.photos.filter(p => {\n        return p.metadata && p.metadata.positionData && p.metadata.positionData.GPSData && p.metadata.positionData.GPSData.latitude && p.metadata.positionData.GPSData.longitude;\n      }).forEach(p => {\n        const mkr = marker({\n          lat: p.metadata.positionData.GPSData.latitude,\n          lng: p.metadata.positionData.GPSData.longitude\n        });\n        this.mapLayersControlOption.overlays.Photos.addLayer(mkr);\n        let width = 500;\n        let height = 500;\n        const size = p.metadata.size;\n        if (size.width > size.height) {\n          height = width * (size.height / size.width);\n        } else {\n          width = height * (size.width / size.height);\n        }\n        const photoTh = this.thumbnailService.getLazyThumbnail(new Media(p, width, height));\n        this.thumbnailsOnLoad.push(photoTh);\n        // Setting popup photo\n        const setPopUpPhoto = () => {\n          const photoPopup = `<img style=\"width: ${width}px; height: ${height}px\" ` + `src=\"${photoTh.Src}\" alt=\"preview\">`;\n          if (!mkr.getPopup()) {\n            mkr.bindPopup(photoPopup, {\n              minWidth: width\n            });\n          } else {\n            mkr.setPopupContent(photoPopup);\n          }\n        };\n        if (photoTh.Available) {\n          setPopUpPhoto();\n        } else {\n          const noPhotoPopup = `<div class=\"lightbox-map-gallery-component-preview-loading\"\n                                 style=\"width: ${width}px; height: ${height}px\">\n                  <span class=\"oi ${photoTh.Error ? 'oi-warning' : 'oi-image'}\"\n                        aria-hidden=\"true\">\n                  </span>\n                  </div>`;\n          mkr.bindPopup(noPhotoPopup, {\n            minWidth: width\n          });\n          mkr.on('popupopen', () => {\n            photoTh.load();\n            photoTh.CurrentlyWaiting = true;\n          });\n          photoTh.OnLoad = setPopUpPhoto;\n        }\n        mkr.setIcon(MarkerFactory.defIcon);\n        // Setting photo icon\n        if (Config.Map.useImageMarkers === true) {\n          mkr.on('add', () => {\n            mkr.off('add');\n            const iconTh = this.thumbnailService.getIcon(new MediaIcon(p));\n            this.thumbnailsOnLoad.push(iconTh);\n            iconTh.Visible = true;\n            const setIcon = () => {\n              mkr.setIcon(icon({\n                iconUrl: iconTh.Src,\n                iconSize: this.usedIconSize,\n                className: 'photo-icon'\n              }));\n              mkr.options.alt = p.name;\n              mkr.on('mouseover', () => {\n                mkr.getIcon().options.iconSize = [this.usedIconSize.x * 1.5, this.usedIconSize.y * 1.5];\n                mkr.setIcon(mkr.getIcon());\n              });\n              mkr.on('mouseout', () => {\n                mkr.getIcon().options.iconSize = this.usedIconSize;\n                mkr.setIcon(mkr.getIcon());\n              });\n            };\n            if (iconTh.Available === true) {\n              setIcon();\n            } else {\n              iconTh.OnLoad = setIcon;\n            }\n          });\n        }\n      });\n      if (this.gpxFiles) {\n        this.loadGPXFiles().catch(console.error);\n      }\n    }\n    loadPreview(mp) {\n      mp.preview.thumbnail.load();\n      mp.preview.thumbnail.CurrentlyWaiting = true;\n    }\n    clearMap() {\n      this.clearImages();\n      this.clearPath();\n    }\n    clearImages() {\n      this.thumbnailsOnLoad.forEach(th => {\n        th.destroy();\n      });\n      this.thumbnailsOnLoad = [];\n      this.mapLayersControlOption.overlays.Photos.clearLayers();\n    }\n    clearPath() {\n      this.pathLayersConfigOrdered.forEach(p => {\n        p.layer.clearLayers();\n        this.mapLayerControl.removeLayer(p.layer);\n      });\n    }\n    onKeyPress(event) {\n      if (this.visible !== true) {\n        return;\n      }\n      switch (event.key) {\n        case 'f':\n        case 'F':\n          if (this.fullScreenService.isFullScreenEnabled()) {\n            this.fullScreenService.exitFullScreen();\n          } else {\n            this.fullScreenService.showFullScreen(this.elementRef.nativeElement);\n          }\n          break;\n        case 'Escape':\n          this.hide();\n          break;\n      }\n    }\n    onMapReady(map) {\n      this.leafletMap = map;\n      this.leafletMap.setMaxZoom(undefined);\n      this.leafletMap.zoomControl.setPosition('bottomright');\n      this.mapLayerControl.addTo(this.leafletMap);\n    }\n    onLeafletZoom() {\n      if (Config.Map.useImageMarkers === false) {\n        return;\n      }\n      if (this.leafletMap.getZoom() < 15 && this.usedIconSize === this.smallIconSize || this.leafletMap.getZoom() >= 15 && this.usedIconSize === this.iconSize) {\n        // all set no change needed\n        return;\n      }\n      this.usedIconSize = this.leafletMap.getZoom() < 15 ? this.smallIconSize : this.iconSize;\n      this.mapLayersControlOption.overlays.Photos.getLayers().forEach(mkr => {\n        // if alt is not present icon is not yet set, so do not change the size\n        if (!mkr.options.alt) {\n          return;\n        }\n        mkr.getIcon().options.iconSize = this.usedIconSize;\n        mkr.setIcon(mkr.getIcon());\n      });\n    }\n    centerMap() {\n      if (this.mapLayersControlOption.overlays.Photos.getLayers().length === 0) {\n        return;\n      }\n      this.leafletMap.fitBounds(latLngBounds(this.mapLayersControlOption.overlays.Photos.getLayers().map(m => m.getLatLng())));\n    }\n    loadGPXFiles() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        _this3.clearPath();\n        if (_this3.gpxFiles.length === 0) {\n          _this3.pathLayersConfigOrdered.forEach(p => {\n            // remove from controls\n            _this3.mapLayerControl.removeLayer(p.layer);\n            // remove from map\n            if (_this3.leafletMap) {\n              _this3.leafletMap.removeLayer(p.layer);\n            }\n          });\n          return;\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < _this3.gpxFiles.length; i++) {\n          const file = _this3.gpxFiles[i];\n          const parsedGPX = yield _this3.mapService.getMapCoordinates(file);\n          if (file !== _this3.gpxFiles[i]) {\n            // check race condition\n            return;\n          }\n          let pathLayer;\n          for (const pl of _this3.pathLayersConfigOrdered) {\n            pathLayer = {\n              layer: pl.layer,\n              icon: MarkerFactory.defIcon\n            };\n            if (!pl.themes || pl.themes.length === 0) {\n              break;\n            }\n            const th = pl.themes.find(th => {\n              return !th.matchers || th.matchers.length == 0 ||\n              // null/empty matchers match everything\n              parsedGPX.name && th.matchers.findIndex(m => m.test(parsedGPX.name)) !== -1;\n            });\n            if (th) {\n              pathLayer.theme = th.theme;\n              pathLayer.icon = th.icon || pathLayer.icon;\n              break;\n            }\n          }\n          if (!pathLayer) {\n            pathLayer = {\n              layer: _this3.pathLayersConfigOrdered[0].layer,\n              icon: MarkerFactory.defIcon\n            };\n          }\n          if (parsedGPX.path.length !== 0) {\n            // render the beginning of the path with a marker\n            const mkr = marker(parsedGPX.path[0]);\n            pathLayer.layer.addLayer(mkr);\n            mkr.setIcon(pathLayer.icon);\n            // Setting popup info\n            mkr.bindPopup(file.name + ': ' + parsedGPX.name);\n            pathLayer.layer.addLayer(polyline(parsedGPX.path, {\n              smoothFactor: 3,\n              interactive: false,\n              color: pathLayer?.theme?.color,\n              dashArray: pathLayer?.theme?.dashArray\n            }));\n          }\n          parsedGPX.markers.forEach(mc => {\n            const mkr = marker(mc);\n            mkr.setIcon(pathLayer.icon);\n            pathLayer.layer.addLayer(mkr);\n            mkr.bindPopup($localize`Latitude` + ': ' + mc.lat + ', ' + $localize`longitude` + ': ' + mc.lng);\n          });\n        }\n        // Add layer to the map\n        _this3.pathLayersConfigOrdered.filter(pl => pl.layer.getLayers().length > 0).forEach(pl => {\n          _this3.mapLayerControl.addOverlay(pl.layer, pl.name);\n          if (_this3.leafletMap && !_this3.leafletMap.hasLayer(pl.layer)) {\n            _this3.leafletMap.addLayer(pl.layer);\n          }\n        });\n      })();\n    }\n  }\n  GalleryMapLightboxComponent.ɵfac = function GalleryMapLightboxComponent_Factory(t) {\n    return new (t || GalleryMapLightboxComponent)(i0.ɵɵdirectiveInject(i1.FullScreenService), i0.ɵɵdirectiveInject(i2.ThumbnailManagerService), i0.ɵɵdirectiveInject(i3.MapService), i0.ɵɵdirectiveInject(i4.ThemeService));\n  };\n  GalleryMapLightboxComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: GalleryMapLightboxComponent,\n    selectors: [[\"app-gallery-map-lightbox\"]],\n    viewQuery: function GalleryMapLightboxComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.elementRef = _t.first);\n      }\n    },\n    hostBindings: function GalleryMapLightboxComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"resize\", function GalleryMapLightboxComponent_resize_HostBindingHandler($event) {\n          return ctx.onResize($event);\n        }, false, i0.ɵɵresolveWindow)(\"keydown\", function GalleryMapLightboxComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyPress($event);\n        }, false, i0.ɵɵresolveWindow);\n      }\n    },\n    inputs: {\n      photos: \"photos\",\n      gpxFiles: \"gpxFiles\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 17,\n    consts: function () {\n      let i18n_1;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\r\n         * @suppress {msgDescriptions}\r\n         */\n        const MSG_EXTERNAL_4199727168861044300$$SRC_FRONTEND_APP_UI_GALLERY_MAP_LIGHTBOX_LIGHTBOX_MAP_GALLERY_COMPONENT_TS__2 = goog.getMsg(\"toggle fullscreen, key: f\");\n        i18n_1 = MSG_EXTERNAL_4199727168861044300$$SRC_FRONTEND_APP_UI_GALLERY_MAP_LIGHTBOX_LIGHTBOX_MAP_GALLERY_COMPONENT_TS__2;\n      } else {\n        i18n_1 = $localize`toggle fullscreen, key: f`;\n      }\n      let i18n_3;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\r\n         * @suppress {msgDescriptions}\r\n         */\n        const MSG_EXTERNAL_4199727168861044300$$SRC_FRONTEND_APP_UI_GALLERY_MAP_LIGHTBOX_LIGHTBOX_MAP_GALLERY_COMPONENT_TS__4 = goog.getMsg(\"toggle fullscreen, key: f\");\n        i18n_3 = MSG_EXTERNAL_4199727168861044300$$SRC_FRONTEND_APP_UI_GALLERY_MAP_LIGHTBOX_LIGHTBOX_MAP_GALLERY_COMPONENT_TS__4;\n      } else {\n        i18n_3 = $localize`toggle fullscreen, key: f`;\n      }\n      let i18n_5;\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        /**\r\n         * @suppress {msgDescriptions}\r\n         */\n        const MSG_EXTERNAL_6587606691006859224$$SRC_FRONTEND_APP_UI_GALLERY_MAP_LIGHTBOX_LIGHTBOX_MAP_GALLERY_COMPONENT_TS__6 = goog.getMsg(\"close, key: Escape\");\n        i18n_5 = MSG_EXTERNAL_6587606691006859224$$SRC_FRONTEND_APP_UI_GALLERY_MAP_LIGHTBOX_LIGHTBOX_MAP_GALLERY_COMPONENT_TS__6;\n      } else {\n        i18n_5 = $localize`close, key: Escape`;\n      }\n      return [[3, \"hidden\"], [\"root\", \"\"], [1, \"lightbox\"], [\"leaflet\", \"\", 3, \"leafletOptions\", \"leafletMapZoom\", \"leafletMapReady\"], [\"id\", \"controllers-container\", 4, \"ngIf\"], [\"id\", \"controllers-container\"], [\"id\", \"controls\"], [\"class\", \"oi  oi-fullscreen-exit highlight\", \"title\", i18n_1, 3, \"click\", 4, \"ngIf\"], [\"class\", \"oi oi-fullscreen-enter highlight\", \"title\", i18n_3, 3, \"click\", 4, \"ngIf\"], [\"title\", i18n_5, 1, \"oi\", \"oi-x\", \"highlight\", 3, \"click\"], [\"title\", i18n_1, 1, \"oi\", \"oi-fullscreen-exit\", \"highlight\", 3, \"click\"], [\"title\", i18n_3, 1, \"oi\", \"oi-fullscreen-enter\", \"highlight\", 3, \"click\"]];\n    },\n    template: function GalleryMapLightboxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0, 1)(2, \"div\", 2)(3, \"div\", 3);\n        i0.ɵɵlistener(\"leafletMapZoom\", function GalleryMapLightboxComponent_Template_div_leafletMapZoom_3_listener() {\n          return ctx.onLeafletZoom();\n        })(\"leafletMapReady\", function GalleryMapLightboxComponent_Template_div_leafletMapReady_3_listener($event) {\n          return ctx.onMapReady($event);\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(4, GalleryMapLightboxComponent_div_4_Template, 8, 2, \"div\", 4);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"hidden\", !ctx.visible);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"width\", ctx.lightboxDimension.width, \"px\")(\"height\", ctx.lightboxDimension.height, \"px\")(\"top\", ctx.lightboxDimension.top, \"px\")(\"left\", ctx.lightboxDimension.left, \"px\")(\"opacity\", ctx.opacity);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.mapDimension.width, \"px\")(\"height\", ctx.mapDimension.height, \"px\");\n        i0.ɵɵproperty(\"leafletOptions\", ctx.mapOptions);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.controllersVisible);\n      }\n    },\n    dependencies: [i5.NgIf, i6.LeafletDirective],\n    styles: [\".lightbox[_ngcontent-%COMP%]{position:fixed;z-index:1100;left:0;top:0;width:100%;height:100%;overflow:hidden;display:flex;justify-content:center;align-items:center;cursor:pointer;transition:all .3s ease-in-out;-o-transition:all .3s ease-in-out;-ms-transition:all .3s ease-in-out;-webkit-transition:all .3s ease-in-out;-moz-transition:all .3s ease-in-out}.sebm-google-map-container[_ngcontent-%COMP%]{width:100%;height:100%}.blackCanvas[_ngcontent-%COMP%]{position:fixed;z-index:1099;left:0;top:0;width:100%;height:100%;background-color:#000;transition:all .3s ease-in-out;-o-transition:all .3s ease-in-out;-ms-transition:all .3s ease-in-out;-webkit-transition:all .3s ease-in-out;-moz-transition:all .3s ease-in-out}#controllers-container[_ngcontent-%COMP%]{z-index:1100;right:0;top:0;position:fixed}#controls[_ngcontent-%COMP%]{top:0;height:initial;text-align:right;width:100%;padding:5px;font-size:large}#controls[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{margin-left:6px;margin-right:6px;color:#000;cursor:pointer}.highlight[_ngcontent-%COMP%]{opacity:.4;transition:opacity .2s ease-out;-moz-transition:opacity .2s ease-out;-webkit-transition:opacity .2s ease-out;-o-transition:opacity .2s ease-out;-ms-transition:opacity .2s ease-out}.highlight[_ngcontent-%COMP%]:hover{opacity:1}  .marker-svg-small .marker-svg-wrapper{width:30px;height:30px;transform:scale(.5)}  .marker-svg-pin{width:30px;height:30px;left:50%;top:50%;margin:-15px 0 0 -15px;border-radius:50% 50% 50% 0;position:absolute;border:3px solid;transform:rotate(-45deg);background-color:#f8f9fa}  .marker-svg-shadow{content:\\\"\\\";background:rgba(128,128,128,.4);width:20px;height:10px;border-radius:100%;position:absolute;top:31px;left:5px}  .custom-div-icon svg{position:absolute;width:16px!important;max-height:20px;inset:0;margin:auto;text-align:center}  .lightbox-map-gallery-component-preview-loading{background-color:#bbb;color:#7f7f7f;font-size:50px}  .lightbox-map-gallery-component-preview-loading span{top:calc(50% - 25px);left:calc(50% - 25px)}  .marker-cluster-small{background-color:#0094ff99;width:30px;height:30px;color:#fff;border-radius:50%!important}  .marker-cluster-small div{background-color:#0094ff;width:20px;height:20px;border-radius:50%!important}  .marker-cluster-small span{line-height:20px}  .marker-cluster-medium{background-color:#007bff99;color:#fff;border-radius:50%!important}  .marker-cluster-medium div{background-color:var(--bs-primary);border-radius:50%!important}  .marker-cluster-large{background-color:#0062ff99;width:50px;height:50px;color:#fff;border-radius:50%!important}  .marker-cluster-large div{background-color:#0062ff;width:40px;height:40px;border-radius:50%!important}  .marker-cluster-large span{font-size:16px;line-height:39px}  img.leaflet-marker-icon.photo-icon{border-radius:50%!important;border:2px rgba(0,123,255,.6) solid}\"]\n  });\n  return GalleryMapLightboxComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}