{"ast":null,"code":"import { NetworkService } from '../../../model/network/network.service';\nimport { GalleryCacheService } from '../cache.gallery.service';\nimport { SearchQueryParserService } from './search-query-parser.service';\nimport { BehaviorSubject } from 'rxjs';\nimport { SearchQueryTypes, TextSearchQueryTypes } from '../../../../../common/entities/SearchQueryDTO';\nimport { QueryParams } from '../../../../../common/QueryParams';\nimport { SearchQueryParser } from '../../../../../common/SearchQueryParser';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../model/network/network.service\";\nimport * as i2 from \"./search-query-parser.service\";\nimport * as i3 from \"../cache.gallery.service\";\nexport let AutoCompleteService = /*#__PURE__*/(() => {\n  class AutoCompleteService {\n    constructor(networkService, searchQueryParserService, galleryCacheService) {\n      this.networkService = networkService;\n      this.searchQueryParserService = searchQueryParserService;\n      this.galleryCacheService = galleryCacheService;\n      this.keywords = [];\n      this.textSearchKeywordsMap = {};\n      this.noACKeywordsMap = {}; // these commands do not have autocompete\n      this.keywords = Object.values(this.searchQueryParserService.keywords).filter(k => k !== this.searchQueryParserService.keywords.or && k !== this.searchQueryParserService.keywords.and && k !== this.searchQueryParserService.keywords.portrait && k !== this.searchQueryParserService.keywords.kmFrom && k !== this.searchQueryParserService.keywords.NSomeOf && k !== this.searchQueryParserService.keywords.minRating && k !== this.searchQueryParserService.keywords.maxRating && k !== this.searchQueryParserService.keywords.every_week && k !== this.searchQueryParserService.keywords.every_month && k !== this.searchQueryParserService.keywords.every_year && k !== this.searchQueryParserService.keywords.weeks_ago && k !== this.searchQueryParserService.keywords.days_ago && k !== this.searchQueryParserService.keywords.months_ago && k !== this.searchQueryParserService.keywords.years_ago && k !== this.searchQueryParserService.keywords.lastNDays).map(k => k + ':');\n      this.keywords.push(this.searchQueryParserService.keywords.and);\n      this.keywords.push(this.searchQueryParserService.keywords.or);\n      for (let i = 0; i < 5; i++) {\n        this.keywords.push(i + '-' + this.searchQueryParserService.keywords.NSomeOf + ':( )');\n      }\n      for (let i = 1; i < 3; i++) {\n        this.keywords.push(this.searchQueryParserService.keywords.lastNDays.replace(/%d/g, i.toString()) + ':');\n      }\n      this.keywords.push(this.searchQueryParserService.keywords.to + ':' + SearchQueryParser.stringifyText(new Date().getFullYear().toString()));\n      this.keywords.push(this.searchQueryParserService.keywords.to + ':' + SearchQueryParser.stringifyText(SearchQueryParser.stringifyDate(Date.now())));\n      this.keywords.push(this.searchQueryParserService.keywords.from + ':' + SearchQueryParser.stringifyText(new Date().getFullYear().toString()));\n      this.keywords.push(this.searchQueryParserService.keywords.from + ':' + SearchQueryParser.stringifyText(SearchQueryParser.stringifyDate(Date.now())));\n      TextSearchQueryTypes.forEach(t => {\n        this.textSearchKeywordsMap[this.searchQueryParserService.keywords[SearchQueryTypes[t]]] = t;\n      });\n      this.noACKeywordsMap[this.searchQueryParserService.keywords.minRating] = SearchQueryTypes.min_rating;\n      this.noACKeywordsMap[this.searchQueryParserService.keywords.maxRating] = SearchQueryTypes.max_rating;\n      this.noACKeywordsMap[this.searchQueryParserService.keywords.minResolution] = SearchQueryTypes.min_resolution;\n      this.noACKeywordsMap[this.searchQueryParserService.keywords.maxResolution] = SearchQueryTypes.max_resolution;\n    }\n    autoComplete(text) {\n      const items = new BehaviorSubject(this.sortResults(text.current, this.getQueryKeywords(text)));\n      const prefixType = this.getTypeFromPrefix(text.current);\n      const searchText = this.getPrefixLessSearchText(text.current);\n      if (searchText === '' || searchText === '.' || prefixType.noAc) {\n        return items;\n      }\n      this.typedAutoComplete(searchText, text.current, prefixType.type, items);\n      return items;\n    }\n    typedAutoComplete(text, fullText, type, items) {\n      items = items || new BehaviorSubject([]);\n      const cached = this.galleryCacheService.getAutoComplete(text, type);\n      try {\n        if (cached == null) {\n          const acParams = {};\n          if (type) {\n            acParams[QueryParams.gallery.search.type] = type;\n          }\n          this.networkService.getJson('/autocomplete/' + text, acParams).then(ret => {\n            this.galleryCacheService.setAutoComplete(text, type, ret);\n            items.next(this.sortResults(fullText, ret.map(i => this.ACItemToRenderable(i, fullText)).concat(items.value)));\n          });\n        } else {\n          items.next(this.sortResults(fullText, cached.map(i => this.ACItemToRenderable(i, fullText)).concat(items.value)));\n        }\n      } catch (e) {\n        console.error(e);\n      }\n      return items;\n    }\n    getPrefixLessSearchText(text) {\n      const tokens = text.split(':');\n      if (tokens.length !== 2) {\n        return text;\n      }\n      // make sure autocomplete works for 'keyword:\"' searches\n      if (tokens[1].charAt(0) === '\"' || tokens[1].charAt(0) === '(') {\n        return tokens[1].substring(1);\n      }\n      return tokens[1];\n    }\n    /**\r\n     * Returns with the type or tells no autocompete recommendations from the server\r\n     * @param text\r\n     * @private\r\n     */\n    getTypeFromPrefix(text) {\n      const tokens = text.split(':');\n      if (tokens.length !== 2) {\n        return {\n          type: null\n        };\n      }\n      if (new RegExp('^\\\\d*-' + this.searchQueryParserService.keywords.kmFrom).test(tokens[0])) {\n        return {\n          type: SearchQueryTypes.distance\n        };\n      }\n      if (this.noACKeywordsMap[tokens[0]]) {\n        return {\n          type: this.noACKeywordsMap[tokens[0]],\n          noAc: true\n        };\n      }\n      return {\n        type: this.textSearchKeywordsMap[tokens[0]] || null\n      };\n    }\n    ACItemToRenderable(item, searchToken) {\n      if (!item.type) {\n        return {\n          text: item.text,\n          queryHint: item.text\n        };\n      }\n      if ((TextSearchQueryTypes.includes(item.type) || item.type === SearchQueryTypes.distance) && item.type !== SearchQueryTypes.any_text) {\n        let queryHint = this.searchQueryParserService.keywords[SearchQueryTypes[item.type]] + ':\"' + item.text + '\"';\n        // if its a distance search, change hint text\n        const tokens = searchToken.split(':');\n        if (tokens.length === 2 && new RegExp('^\\\\d*-' + this.searchQueryParserService.keywords.kmFrom).test(tokens[0])) {\n          queryHint = tokens[0] + ':\"' + item.text + '\"';\n        }\n        return {\n          text: item.text,\n          type: item.type,\n          queryHint\n        };\n      }\n      return {\n        text: item.text,\n        type: item.type,\n        queryHint: item.text\n      };\n    }\n    sortResults(text, items) {\n      const textLC = text.toLowerCase();\n      // Source: https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\n      const isStartRgx = new RegExp('(\\\\s|^)' + textLC.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i');\n      return items.sort((a, b) => {\n        const aLC = a.text.toLowerCase();\n        const bLC = b.text.toLowerCase();\n        const basicCompare = () => {\n          // prioritize persons higher\n          if (a.type !== b.type) {\n            if (a.type === SearchQueryTypes.person) {\n              return -1;\n            } else if (b.type === SearchQueryTypes.person) {\n              return 1;\n            }\n          }\n          return aLC.localeCompare(bLC);\n        };\n        // both starts with the searched string\n        if (aLC.startsWith(textLC) && bLC.startsWith(textLC)) {\n          return basicCompare();\n          // none starts with the searched string\n        } else if (!aLC.startsWith(textLC) && !bLC.startsWith(textLC)) {\n          if (isStartRgx.test(aLC) && isStartRgx.test(bLC) || !isStartRgx.test(aLC) && !isStartRgx.test(bLC)) {\n            return basicCompare();\n          } else if (isStartRgx.test(aLC)) {\n            return -1;\n          }\n          return 1;\n          // one of them starts with the searched string\n        } else if (aLC.startsWith(textLC)) {\n          return -1;\n        }\n        return 1;\n      });\n    }\n    getQueryKeywords(text) {\n      // if empty, recommend \"and\"\n      if (text.current === '') {\n        if (text.prev !== this.searchQueryParserService.keywords.and) {\n          return [{\n            text: this.searchQueryParserService.keywords.and,\n            queryHint: this.searchQueryParserService.keywords.and,\n            notSearchable: true\n          }];\n        } else {\n          return [];\n        }\n      }\n      const generateMatch = key => ({\n        text: key,\n        queryHint: key,\n        notSearchable: true\n      });\n      const ret = this.keywords.filter(key => key.startsWith(text.current.toLowerCase())).map(generateMatch);\n      // make KmFrom sensitive to all positive distances\n      const starterNum = parseInt(text.current);\n      if (starterNum > 0) {\n        const key = starterNum + '-' + this.searchQueryParserService.keywords.kmFrom + ':';\n        if (key.startsWith(text.current.toLowerCase())) {\n          ret.push(generateMatch(key));\n        }\n      }\n      // only showing rating recommendations of the full query is typed\n      const mrKey = this.searchQueryParserService.keywords.minRating + ':';\n      const mxrKey = this.searchQueryParserService.keywords.maxRating + ':';\n      if (text.current.toLowerCase().startsWith(mrKey)) {\n        for (let i = 1; i <= 5; ++i) {\n          ret.push(generateMatch(mrKey + i));\n        }\n      } else if (mrKey.startsWith(text.current.toLowerCase())) {\n        ret.push(generateMatch(mrKey));\n      }\n      if (text.current.toLowerCase().startsWith(mxrKey)) {\n        for (let i = 1; i <= 5; ++i) {\n          ret.push(generateMatch(mxrKey + i));\n        }\n      } else if (mxrKey.startsWith(text.current.toLowerCase())) {\n        ret.push(generateMatch(mxrKey));\n      }\n      // Date patterns\n      if (new RegExp('^' + SearchQueryParser.humanToRegexpStr(this.searchQueryParserService.keywords.lastNDays) + '!?:$', 'i').test(text.current) || new RegExp('^' + this.searchQueryParserService.keywords.sameDay + '!?:$', 'i').test(text.current)) {\n        ret.push(generateMatch(text.current + this.searchQueryParserService.keywords.every_week));\n        ret.push(generateMatch(text.current + this.searchQueryParserService.keywords.every_month));\n        ret.push(generateMatch(text.current + this.searchQueryParserService.keywords.every_year));\n        ret.push(generateMatch(text.current + this.searchQueryParserService.keywords.days_ago.replace(/%d/g, '2')));\n        ret.push(generateMatch(text.current + this.searchQueryParserService.keywords.weeks_ago.replace(/%d/g, '2')));\n        ret.push(generateMatch(text.current + this.searchQueryParserService.keywords.months_ago.replace(/%d/g, '2')));\n        ret.push(generateMatch(text.current + this.searchQueryParserService.keywords.years_ago.replace(/%d/g, '2')));\n      }\n      return ret;\n    }\n  }\n  AutoCompleteService.ɵfac = function AutoCompleteService_Factory(t) {\n    return new (t || AutoCompleteService)(i0.ɵɵinject(i1.NetworkService), i0.ɵɵinject(i2.SearchQueryParserService), i0.ɵɵinject(i3.GalleryCacheService));\n  };\n  AutoCompleteService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AutoCompleteService,\n    factory: AutoCompleteService.ɵfac\n  });\n  return AutoCompleteService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}