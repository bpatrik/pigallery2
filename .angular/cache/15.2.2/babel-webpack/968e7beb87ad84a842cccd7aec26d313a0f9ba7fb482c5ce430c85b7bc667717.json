{"ast":null,"code":"import { DatePatternFrequency, SearchQueryTypes, TextSearchQueryMatchTypes, TextSearchQueryTypes } from './entities/SearchQueryDTO';\nimport { Utils } from './Utils';\nexport const defaultQueryKeywords = {\n  NSomeOf: 'of',\n  and: 'and',\n  or: 'or',\n  from: 'after',\n  to: 'before',\n  maxRating: 'max-rating',\n  maxResolution: 'max-resolution',\n  minRating: 'min-rating',\n  minResolution: 'min-resolution',\n  kmFrom: 'km-from',\n  orientation: 'orientation',\n  landscape: 'landscape',\n  portrait: 'portrait',\n  years_ago: '%d-years-ago',\n  months_ago: '%d-months-ago',\n  weeks_ago: '%d-weeks-ago',\n  days_ago: '%d-days-ago',\n  every_year: 'every-year',\n  every_month: 'every-month',\n  every_week: 'every-week',\n  lastNDays: 'last-%d-days',\n  sameDay: 'same-day',\n  any_text: 'any-text',\n  keyword: 'keyword',\n  caption: 'caption',\n  directory: 'directory',\n  file_name: 'file-name',\n  person: 'person',\n  position: 'position',\n  someOf: 'some-of'\n};\nexport class SearchQueryParser {\n  constructor(keywords = defaultQueryKeywords) {\n    this.keywords = keywords;\n  }\n  static stringifyText(text, matchType = TextSearchQueryMatchTypes.like) {\n    if (matchType === TextSearchQueryMatchTypes.exact_match) {\n      return '\"' + text + '\"';\n    }\n    if (text.indexOf(' ') !== -1) {\n      return '(' + text + ')';\n    }\n    return text;\n  }\n  static stringifyDate(time) {\n    const date = new Date(time);\n    // simplify date with yeah only if its first of jan\n    if (date.getMonth() === 0 && date.getDate() === 1) {\n      return date.getFullYear().toString();\n    }\n    return this.stringifyText(date.toISOString().substring(0, 10));\n  }\n  static parseDate(text) {\n    if (text.charAt(0) === '\"' || text.charAt(0) === '(') {\n      text = text.substring(1);\n    }\n    if (text.charAt(text.length - 1) === '\"' || text.charAt(text.length - 1) === ')') {\n      text = text.substring(0, text.length - 1);\n    }\n    // it is the year only\n    if (text.length === 4) {\n      return Date.UTC(parseInt(text, 10), 0, 1, 0, 0, 0, 0);\n    }\n    let timestamp = null;\n    // Parsing ISO string\n    try {\n      const parts = text.split('-').map(t => parseInt(t, 10));\n      if (parts && parts.length === 2) {\n        timestamp = Date.UTC(parts[0], parts[1] - 1, 1, 0, 0, 0, 0); // Note: months are 0-based\n      }\n\n      if (parts && parts.length === 3) {\n        timestamp = Date.UTC(parts[0], parts[1] - 1, parts[2], 0, 0, 0, 0); // Note: months are 0-based\n      }\n    } catch (e) {\n      // ignoring errors\n    }\n    // If it could not parse as ISO string, try our luck with Date.parse\n    // https://stackoverflow.com/questions/2587345/why-does-date-parse-give-incorrect-results\n    if (timestamp === null) {\n      timestamp = Date.parse(text);\n    }\n    if (isNaN(timestamp) || timestamp === null) {\n      throw new Error('Cannot parse date: ' + text);\n    }\n    return timestamp;\n  }\n  static humanToRegexpStr(str) {\n    return str.replace(/%d/g, '\\\\d*');\n  }\n  parse(str, implicitAND = true) {\n    str = str.replace(/\\s\\s+/g, ' ') // remove double spaces\n    .replace(/:\\s+/g, ':').trim();\n    const intFromRegexp = str => {\n      return parseInt(new RegExp(/\\d+/).exec(str)[0], 10);\n    };\n    if (str.charAt(0) === '(' && str.charAt(str.length - 1) === ')') {\n      str = str.slice(1, str.length - 1);\n    }\n    const fistSpace = (start = 0) => {\n      const bracketIn = [];\n      let quotationMark = false;\n      for (let i = start; i < str.length; ++i) {\n        if (str.charAt(i) === '\"') {\n          quotationMark = !quotationMark;\n          continue;\n        }\n        if (str.charAt(i) === '(') {\n          bracketIn.push(i);\n          continue;\n        }\n        if (str.charAt(i) === ')') {\n          bracketIn.pop();\n          continue;\n        }\n        if (quotationMark === false && bracketIn.length === 0 && str.charAt(i) === ' ') {\n          return i;\n        }\n      }\n      return str.length - 1;\n    };\n    // tokenize\n    const tokenEnd = fistSpace();\n    if (tokenEnd !== str.length - 1) {\n      if (str.startsWith(' ' + this.keywords.and, tokenEnd)) {\n        const rest = this.parse(str.slice(tokenEnd + (' ' + this.keywords.and).length), implicitAND);\n        return {\n          type: SearchQueryTypes.AND,\n          list: [this.parse(str.slice(0, tokenEnd), implicitAND), ...(rest.type === SearchQueryTypes.AND ? rest.list : [rest])]\n        };\n      } else if (str.startsWith(' ' + this.keywords.or, tokenEnd)) {\n        const rest = this.parse(str.slice(tokenEnd + (' ' + this.keywords.or).length), implicitAND);\n        return {\n          type: SearchQueryTypes.OR,\n          list: [this.parse(str.slice(0, tokenEnd), implicitAND), ...(rest.type === SearchQueryTypes.OR ? rest.list : [rest])]\n        };\n      } else {\n        // Relation cannot be detected\n        const t = implicitAND === true ? SearchQueryTypes.AND : SearchQueryTypes.UNKNOWN_RELATION;\n        const rest = this.parse(str.slice(tokenEnd), implicitAND);\n        return {\n          type: t,\n          list: [this.parse(str.slice(0, tokenEnd), implicitAND), ...(rest.type === t ? rest.list : [rest])]\n        };\n      }\n    }\n    if (str.startsWith(this.keywords.someOf + ':') || new RegExp('^\\\\d*-' + this.keywords.NSomeOf + ':').test(str)) {\n      const prefix = str.startsWith(this.keywords.someOf + ':') ? this.keywords.someOf + ':' : new RegExp('^\\\\d*-' + this.keywords.NSomeOf + ':').exec(str)[0];\n      let tmpList = this.parse(str.slice(prefix.length + 1, -1), false); // trim brackets\n      const unfoldList = q => {\n        if (q.list) {\n          if (q.type === SearchQueryTypes.UNKNOWN_RELATION) {\n            return q.list.map(e => unfoldList(e)).flat(); // flatten array\n          } else {\n            q.list.forEach(e => unfoldList(e));\n          }\n        }\n        return [q];\n      };\n      tmpList = unfoldList(tmpList);\n      const ret = {\n        type: SearchQueryTypes.SOME_OF,\n        list: tmpList\n      };\n      if (new RegExp('^\\\\d*-' + this.keywords.NSomeOf + ':').test(str)) {\n        ret.min = parseInt(new RegExp(/^\\d*/).exec(str)[0], 10);\n      }\n      return ret;\n    }\n    const kwStartsWith = (s, kw) => {\n      return s.startsWith(kw + ':') || s.startsWith(kw + '!:');\n    };\n    if (kwStartsWith(str, this.keywords.from)) {\n      return {\n        type: SearchQueryTypes.from_date,\n        value: SearchQueryParser.parseDate(str.substring(str.indexOf(':') + 1)),\n        ...(str.startsWith(this.keywords.from + '!:') && {\n          negate: true\n        }) // only add if the value is true\n      };\n    }\n\n    if (kwStartsWith(str, this.keywords.to)) {\n      return {\n        type: SearchQueryTypes.to_date,\n        value: SearchQueryParser.parseDate(str.substring(str.indexOf(':') + 1)),\n        ...(str.startsWith(this.keywords.to + '!:') && {\n          negate: true\n        }) // only add if the value is true\n      };\n    }\n\n    if (kwStartsWith(str, this.keywords.minRating)) {\n      return {\n        type: SearchQueryTypes.min_rating,\n        value: parseInt(str.substring(str.indexOf(':') + 1), 10),\n        ...(str.startsWith(this.keywords.minRating + '!:') && {\n          negate: true\n        }) // only add if the value is true\n      };\n    }\n\n    if (kwStartsWith(str, this.keywords.maxRating)) {\n      return {\n        type: SearchQueryTypes.max_rating,\n        value: parseInt(str.substring(str.indexOf(':') + 1), 10),\n        ...(str.startsWith(this.keywords.maxRating + '!:') && {\n          negate: true\n        }) // only add if the value is true\n      };\n    }\n\n    if (kwStartsWith(str, this.keywords.minResolution)) {\n      return {\n        type: SearchQueryTypes.min_resolution,\n        value: parseInt(str.substring(str.indexOf(':') + 1), 10),\n        ...(str.startsWith(this.keywords.minResolution + '!:') && {\n          negate: true\n        }) // only add if the value is true\n      };\n    }\n\n    if (kwStartsWith(str, this.keywords.maxResolution)) {\n      return {\n        type: SearchQueryTypes.max_resolution,\n        value: parseInt(str.substring(str.indexOf(':') + 1), 10),\n        ...(str.startsWith(this.keywords.maxResolution + '!:') && {\n          negate: true\n        }) // only add if the value is true\n      };\n    }\n\n    if (new RegExp('^\\\\d*-' + this.keywords.kmFrom + '!?:').test(str)) {\n      let from = str.slice(new RegExp('^\\\\d*-' + this.keywords.kmFrom + '!?:').exec(str)[0].length);\n      if (from.charAt(0) === '(' && from.charAt(from.length - 1) === ')' || from.charAt(0) === '\"' && from.charAt(from.length - 1) === '\"') {\n        from = from.slice(1, from.length - 1);\n      }\n      return {\n        type: SearchQueryTypes.distance,\n        distance: intFromRegexp(str),\n        from: {\n          text: from\n        },\n        ...(new RegExp('^\\\\d*-' + this.keywords.kmFrom + '!:').test(str) && {\n          negate: true\n        }) // only add if the value is true\n      };\n    }\n\n    if (str.startsWith(this.keywords.orientation + ':')) {\n      return {\n        type: SearchQueryTypes.orientation,\n        landscape: str.slice((this.keywords.orientation + ':').length) === this.keywords.landscape\n      };\n    }\n    if (kwStartsWith(str, this.keywords.sameDay) || new RegExp('^' + SearchQueryParser.humanToRegexpStr(this.keywords.lastNDays) + '!?:').test(str)) {\n      const freqStr = str.slice(str.indexOf(':') + 1);\n      let freq = null;\n      let ago;\n      if (freqStr == this.keywords.every_week) {\n        freq = DatePatternFrequency.every_week;\n      } else if (freqStr == this.keywords.every_month) {\n        freq = DatePatternFrequency.every_month;\n      } else if (freqStr == this.keywords.every_year) {\n        freq = DatePatternFrequency.every_year;\n      } else if (new RegExp('^' + SearchQueryParser.humanToRegexpStr(this.keywords.days_ago) + '$').test(freqStr)) {\n        freq = DatePatternFrequency.days_ago;\n        ago = intFromRegexp(freqStr);\n      } else if (new RegExp('^' + SearchQueryParser.humanToRegexpStr(this.keywords.weeks_ago) + '$').test(freqStr)) {\n        freq = DatePatternFrequency.weeks_ago;\n        ago = intFromRegexp(freqStr);\n      } else if (new RegExp('^' + SearchQueryParser.humanToRegexpStr(this.keywords.months_ago) + '$').test(freqStr)) {\n        freq = DatePatternFrequency.months_ago;\n        ago = intFromRegexp(freqStr);\n      } else if (new RegExp('^' + SearchQueryParser.humanToRegexpStr(this.keywords.years_ago) + '$').test(freqStr)) {\n        freq = DatePatternFrequency.years_ago;\n        ago = intFromRegexp(freqStr);\n      }\n      if (freq) {\n        const ret = {\n          type: SearchQueryTypes.date_pattern,\n          daysLength: kwStartsWith(str, this.keywords.sameDay) ? 0 : intFromRegexp(str),\n          frequency: freq\n        };\n        if (ago) {\n          ret.agoNumber = ago;\n        }\n        return ret;\n      }\n    }\n    // parse text search\n    const tmp = TextSearchQueryTypes.map(type => ({\n      key: this.keywords[SearchQueryTypes[type]] + ':',\n      queryTemplate: {\n        type,\n        text: ''\n      }\n    })).concat(TextSearchQueryTypes.map(type => ({\n      key: this.keywords[SearchQueryTypes[type]] + '!:',\n      queryTemplate: {\n        type,\n        text: '',\n        negate: true\n      }\n    })));\n    for (const typeTmp of tmp) {\n      if (str.startsWith(typeTmp.key)) {\n        const ret = Utils.clone(typeTmp.queryTemplate);\n        // exact match\n        if (str.charAt(typeTmp.key.length) === '\"' && str.charAt(str.length - 1) === '\"') {\n          ret.text = str.slice(typeTmp.key.length + 1, str.length - 1);\n          ret.matchType = TextSearchQueryMatchTypes.exact_match;\n          // like match\n        } else if (str.charAt(typeTmp.key.length) === '(' && str.charAt(str.length - 1) === ')') {\n          ret.text = str.slice(typeTmp.key.length + 1, str.length - 1);\n        } else {\n          ret.text = str.slice(typeTmp.key.length);\n        }\n        return ret;\n      }\n    }\n    return {\n      type: SearchQueryTypes.any_text,\n      text: str\n    };\n  }\n  stringify(query) {\n    const ret = this.stringifyOnEntry(query);\n    if (ret.charAt(0) === '(' && ret.charAt(ret.length - 1) === ')') {\n      return ret.slice(1, ret.length - 1);\n    }\n    return ret;\n  }\n  stringifyOnEntry(query) {\n    if (!query || !query.type) {\n      return '';\n    }\n    const colon = query.negate === true ? '!:' : ':';\n    switch (query.type) {\n      case SearchQueryTypes.AND:\n        return '(' + query.list.map(q => this.stringifyOnEntry(q)).join(' ' + this.keywords.and + ' ') + ')';\n      case SearchQueryTypes.OR:\n        return '(' + query.list.map(q => this.stringifyOnEntry(q)).join(' ' + this.keywords.or + ' ') + ')';\n      case SearchQueryTypes.SOME_OF:\n        if (query.min) {\n          return query.min + '-' + this.keywords.NSomeOf + ':(' + query.list.map(q => this.stringifyOnEntry(q)).join(' ') + ')';\n        }\n        return this.keywords.someOf + ':(' + query.list.map(q => this.stringifyOnEntry(q)).join(' ') + ')';\n      case SearchQueryTypes.from_date:\n        if (!query.value) {\n          return '';\n        }\n        return this.keywords.from + colon + SearchQueryParser.stringifyDate(query.value);\n      case SearchQueryTypes.to_date:\n        if (!query.value) {\n          return '';\n        }\n        return this.keywords.to + colon + SearchQueryParser.stringifyDate(query.value);\n      case SearchQueryTypes.min_rating:\n        return this.keywords.minRating + colon + (isNaN(query.value) ? '' : query.value);\n      case SearchQueryTypes.max_rating:\n        return this.keywords.maxRating + colon + (isNaN(query.value) ? '' : query.value);\n      case SearchQueryTypes.min_resolution:\n        return this.keywords.minResolution + colon + (isNaN(query.value) ? '' : query.value);\n      case SearchQueryTypes.max_resolution:\n        return this.keywords.maxResolution + colon + (isNaN(query.value) ? '' : query.value);\n      case SearchQueryTypes.distance:\n        if (query.from.text.indexOf(' ') !== -1) {\n          return query.distance + '-' + this.keywords.kmFrom + colon + '(' + query.from.text + ')';\n        }\n        return query.distance + '-' + this.keywords.kmFrom + colon + query.from.text;\n      case SearchQueryTypes.orientation:\n        return this.keywords.orientation + ':' + (query.landscape ? this.keywords.landscape : this.keywords.portrait);\n      case SearchQueryTypes.date_pattern:\n        {\n          const q = query;\n          q.daysLength = q.daysLength || 0;\n          let strBuilder = '';\n          if (q.daysLength <= 0) {\n            strBuilder += this.keywords.sameDay;\n          } else {\n            strBuilder += this.keywords.lastNDays.replace(/%d/g, q.daysLength.toString());\n          }\n          strBuilder += ':';\n          switch (q.frequency) {\n            case DatePatternFrequency.every_week:\n              strBuilder += this.keywords.every_week;\n              break;\n            case DatePatternFrequency.every_month:\n              strBuilder += this.keywords.every_month;\n              break;\n            case DatePatternFrequency.every_year:\n              strBuilder += this.keywords.every_year;\n              break;\n            case DatePatternFrequency.days_ago:\n              strBuilder += this.keywords.days_ago.replace(/%d/g, (q.agoNumber || 0).toString());\n              break;\n            case DatePatternFrequency.weeks_ago:\n              strBuilder += this.keywords.weeks_ago.replace(/%d/g, (q.agoNumber || 0).toString());\n              break;\n            case DatePatternFrequency.months_ago:\n              strBuilder += this.keywords.months_ago.replace(/%d/g, (q.agoNumber || 0).toString());\n              break;\n            case DatePatternFrequency.years_ago:\n              strBuilder += this.keywords.years_ago.replace(/%d/g, (q.agoNumber || 0).toString());\n              break;\n          }\n          return strBuilder;\n        }\n      case SearchQueryTypes.any_text:\n        if (!query.negate) {\n          return SearchQueryParser.stringifyText(query.text, query.matchType);\n        } else {\n          return this.keywords[SearchQueryTypes[query.type]] + colon + SearchQueryParser.stringifyText(query.text, query.matchType);\n        }\n      case SearchQueryTypes.person:\n      case SearchQueryTypes.position:\n      case SearchQueryTypes.keyword:\n      case SearchQueryTypes.caption:\n      case SearchQueryTypes.file_name:\n      case SearchQueryTypes.directory:\n        if (!query.text) {\n          return '';\n        }\n        return this.keywords[SearchQueryTypes[query.type]] + colon + SearchQueryParser.stringifyText(query.text, query.matchType);\n      default:\n        throw new Error('Unknown type: ' + query.type);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}