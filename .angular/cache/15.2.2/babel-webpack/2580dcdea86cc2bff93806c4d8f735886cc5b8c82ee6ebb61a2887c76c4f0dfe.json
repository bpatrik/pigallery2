{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport { map, switchMap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nexport var FilterRenderType = /*#__PURE__*/(() => {\n  (function (FilterRenderType) {\n    FilterRenderType[FilterRenderType[\"enum\"] = 1] = \"enum\";\n    FilterRenderType[FilterRenderType[\"range\"] = 2] = \"range\";\n  })(FilterRenderType || (FilterRenderType = {}));\n  return FilterRenderType;\n})();\nexport let FilterService = /*#__PURE__*/(() => {\n  class FilterService {\n    constructor() {\n      this.AVAILABLE_FILTERS = [{\n        name: $localize`Keywords`,\n        mapFn: m => m.metadata.keywords,\n        renderType: FilterRenderType.enum,\n        isArrayValue: true\n      }, {\n        name: $localize`Faces`,\n        mapFn: m => m.metadata.faces ? m.metadata.faces.map(f => f.name) : ['<' + $localize`no face` + '>'],\n        renderType: FilterRenderType.enum,\n        isArrayValue: true\n      }, {\n        name: $localize`Faces groups`,\n        mapFn: m => m.metadata.faces?.map(f => f.name).sort().join(', '),\n        renderType: FilterRenderType.enum,\n        isArrayValue: false\n      }, {\n        name: $localize`Caption`,\n        mapFn: m => m.metadata.caption,\n        renderType: FilterRenderType.enum\n      }, {\n        name: $localize`Rating`,\n        mapFn: m => m.metadata.rating,\n        renderType: FilterRenderType.enum\n      }, {\n        name: $localize`Camera`,\n        mapFn: m => m.metadata.cameraData?.model,\n        renderType: FilterRenderType.enum\n      }, {\n        name: $localize`Lens`,\n        mapFn: m => m.metadata.cameraData?.lens,\n        renderType: FilterRenderType.enum\n      }, {\n        name: $localize`City`,\n        mapFn: m => m.metadata.positionData?.city,\n        renderType: FilterRenderType.enum\n      }, {\n        name: $localize`State`,\n        mapFn: m => m.metadata.positionData?.state,\n        renderType: FilterRenderType.enum\n      }, {\n        name: $localize`Country`,\n        mapFn: m => m.metadata.positionData?.country,\n        renderType: FilterRenderType.enum\n      }];\n      this.activeFilters = new BehaviorSubject({\n        filtersVisible: false,\n        areFiltersActive: false,\n        dateFilter: {\n          minDate: 0,\n          maxDate: Date.now(),\n          minFilter: Number.MIN_VALUE,\n          maxFilter: Number.MAX_VALUE\n        },\n        selectedFilters: [{\n          filter: this.AVAILABLE_FILTERS[0],\n          options: []\n        }, {\n          filter: this.AVAILABLE_FILTERS[1],\n          options: []\n        }, {\n          filter: this.AVAILABLE_FILTERS[7],\n          options: []\n        }, {\n          filter: this.AVAILABLE_FILTERS[4],\n          options: []\n        }]\n      });\n      this.statistic = [];\n    }\n    getStatistic(prefiltered) {\n      if (!prefiltered || !prefiltered.media || prefiltered.media.length === 0) {\n        return [];\n      }\n      const ret = [];\n      const minDate = prefiltered.media.reduce((p, curr) => Math.min(p, curr.metadata.creationDate), Number.MAX_VALUE - 1);\n      const maxDate = prefiltered.media.reduce((p, curr) => Math.max(p, curr.metadata.creationDate), Number.MIN_VALUE + 1);\n      const diff = (maxDate - minDate) / 1000;\n      const H = 60 * 60;\n      const D = H * 24;\n      const M = D * 30;\n      const Y = D * 365;\n      const Y2 = Y * 2;\n      const Y5 = Y * 5;\n      const Dec = Y * 10;\n      const Dec2 = Y * 20;\n      const Dec5 = Y * 50;\n      const Sen = Y * 100;\n      const divs = [H, D, M, Y, Y2, Y5, Dec, Dec2, Dec5, Sen];\n      // finding the resolution\n      let usedDiv = H;\n      for (let i = 0; i < divs.length; ++i) {\n        if (diff / divs[i] < 26) {\n          usedDiv = divs[i];\n          break;\n        }\n      }\n      // getting the first date (truncated to the resolution)\n      const floorDate = ts => {\n        let d = new Date(ts);\n        if (usedDiv >= Y) {\n          const fy = d.getFullYear();\n          d = new Date(fy - fy % (usedDiv / Y), 0, 1);\n        } else if (usedDiv === M) {\n          d = new Date(d.getFullYear(), d.getMonth(), 1);\n        } else {\n          d = new Date(ts - ts % usedDiv);\n        }\n        return d.getTime();\n      };\n      const startMediaDate = new Date(floorDate(minDate));\n      prefiltered.media.forEach(m => {\n        const key = Math.floor((floorDate(m.metadata.creationDate) - startMediaDate.getTime()) / 1000 / usedDiv);\n        const getDate = index => {\n          let d;\n          if (usedDiv >= Y) {\n            d = new Date(startMediaDate.getFullYear() + index * (usedDiv / Y), 0, 1);\n          } else if (usedDiv === M) {\n            d = new Date(startMediaDate.getFullYear(), startMediaDate.getMonth() + index, 1);\n          } else if (usedDiv === D) {\n            d = new Date(startMediaDate.getFullYear(), startMediaDate.getMonth(), startMediaDate.getDate() + index, 1);\n          } else {\n            d = new Date(startMediaDate.getTime() + index * usedDiv * 1000);\n          }\n          return d;\n        };\n        // extending the array\n        while (ret.length <= key) {\n          let dStr;\n          // getting date range start for entry and also UI date pattern\n          if (usedDiv >= Y) {\n            dStr = 'y';\n          } else if (usedDiv === M) {\n            dStr = 'y MMM';\n          } else if (usedDiv === D) {\n            dStr = 'EEE';\n          } else {\n            dStr = 'HH';\n          }\n          ret.push({\n            date: getDate(ret.length),\n            endDate: getDate(ret.length + 1),\n            dateStr: dStr,\n            count: 0,\n            max: 0\n          });\n        }\n        ret[key].count++;\n      });\n      // don't show if there is only one column\n      if (ret.length <= 1) {\n        return [];\n      }\n      const max = ret.reduce((p, c) => Math.max(p, c.count), 0);\n      ret.forEach(v => v.max = max);\n      return ret;\n    }\n    applyFilters(directoryContent) {\n      return directoryContent.pipe(switchMap(dirContent => {\n        this.statistic = this.getStatistic(dirContent);\n        this.resetFilters(false);\n        return this.activeFilters.pipe(map(afilters => {\n          if (!dirContent || !dirContent.media || !afilters.filtersVisible && !afilters.areFiltersActive) {\n            return dirContent;\n          }\n          // clone, so the original won't get overwritten\n          const c = {\n            media: dirContent.media,\n            directories: dirContent.directories,\n            metaFile: dirContent.metaFile\n          };\n          /* Date Selector */\n          if (c.media.length > 0) {\n            // Update date filter range\n            afilters.dateFilter.minDate = c.media.reduce((p, curr) => Math.min(p, curr.metadata.creationDate), Number.MAX_VALUE - 1);\n            afilters.dateFilter.maxDate = c.media.reduce((p, curr) => Math.max(p, curr.metadata.creationDate), Number.MIN_VALUE + 1);\n            // Add a few sec padding\n            afilters.dateFilter.minDate -= afilters.dateFilter.minDate % 1000 + 1000;\n            afilters.dateFilter.maxDate += afilters.dateFilter.maxDate % 1000 + 1000;\n            if (afilters.dateFilter.minFilter === Number.MIN_VALUE) {\n              afilters.dateFilter.minFilter = afilters.dateFilter.minDate;\n            }\n            if (afilters.dateFilter.maxFilter === Number.MAX_VALUE) {\n              afilters.dateFilter.maxFilter = afilters.dateFilter.maxDate;\n            }\n            // Apply Date filter\n            c.media = c.media.filter(m => m.metadata.creationDate >= afilters.dateFilter.minFilter && m.metadata.creationDate <= afilters.dateFilter.maxFilter);\n          } else {\n            afilters.dateFilter.minDate = Number.MIN_VALUE;\n            afilters.dateFilter.maxDate = Number.MAX_VALUE;\n            afilters.dateFilter.minFilter = Number.MIN_VALUE;\n            afilters.dateFilter.maxFilter = Number.MAX_VALUE;\n          }\n          // filters\n          for (const f of afilters.selectedFilters) {\n            /* Update filter options */\n            const valueMap = {};\n            f.options.forEach(o => {\n              valueMap[o.name] = o;\n              o.count = 0; // reset count so unknown option can be removed at the end\n            });\n\n            if (f.filter.isArrayValue) {\n              c.media.forEach(m => {\n                f.filter.mapFn(m)?.forEach(v => {\n                  valueMap[v] = valueMap[v] || {\n                    name: v,\n                    count: 0,\n                    selected: true\n                  };\n                  valueMap[v].count++;\n                });\n              });\n            } else {\n              c.media.forEach(m => {\n                const key = f.filter.mapFn(m);\n                valueMap[key] = valueMap[key] || {\n                  name: key,\n                  count: 0,\n                  selected: true\n                };\n                valueMap[key].count++;\n              });\n            }\n            f.options = Object.values(valueMap).filter(o => o.count > 0).sort((a, b) => b.count - a.count);\n            /* Apply filters */\n            f.options.forEach(opt => {\n              if (opt.selected) {\n                return;\n              }\n              if (f.filter.isArrayValue) {\n                c.media = c.media.filter(m => {\n                  const mapped = f.filter.mapFn(m);\n                  if (!mapped) {\n                    return true;\n                  }\n                  return mapped.indexOf(opt.name) === -1;\n                });\n              } else {\n                c.media = c.media.filter(m => f.filter.mapFn(m) !== opt.name);\n              }\n            });\n          }\n          // If th e number of photos did not change, the filters are not active\n          afilters.areFiltersActive = c.media.length !== dirContent.media.length;\n          return c;\n        }));\n      }));\n    }\n    onFilterChange() {\n      this.activeFilters.next(this.activeFilters.value);\n    }\n    setShowingFilters(value) {\n      if (this.activeFilters.value.filtersVisible === value) {\n        return;\n      }\n      this.activeFilters.value.filtersVisible = value;\n      if (!this.activeFilters.value.filtersVisible && !this.activeFilters.value.areFiltersActive) {\n        this.resetFilters(false);\n      }\n      this.onFilterChange();\n    }\n    resetFilters(triggerChangeDetection = true) {\n      this.activeFilters.value.dateFilter.minFilter = Number.MIN_VALUE;\n      this.activeFilters.value.dateFilter.maxFilter = Number.MAX_VALUE;\n      this.activeFilters.value.selectedFilters.forEach(f => f.options = []);\n      if (triggerChangeDetection) {\n        this.onFilterChange();\n      }\n    }\n  }\n  FilterService.ɵfac = function FilterService_Factory(t) {\n    return new (t || FilterService)();\n  };\n  FilterService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FilterService,\n    factory: FilterService.ɵfac\n  });\n  return FilterService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}