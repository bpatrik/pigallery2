{"ast":null,"code":"import { ChangeDetectorRef, ElementRef, QueryList } from '@angular/core';\nimport { GridRowBuilder } from './GridRowBuilder';\nimport { GalleryLightboxComponent } from '../lightbox/lightbox.gallery.component';\nimport { GridMedia } from './GridMedia';\nimport { GalleryPhotoComponent } from './photo/photo.grid.gallery.component';\nimport { OverlayService } from '../overlay.service';\nimport { Config } from '../../../../../common/config/public/Config';\nimport { PageHelper } from '../../../model/page.helper';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { QueryService } from '../../../model/query.service';\nimport { ContentService } from '../content.service';\nimport { MediaDTOUtils } from '../../../../../common/entities/MediaDTO';\nimport { QueryParams } from '../../../../../common/QueryParams';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../overlay.service\";\nimport * as i2 from \"../../../model/query.service\";\nimport * as i3 from \"@angular/router\";\nimport * as i4 from \"../content.service\";\nimport * as i5 from \"@angular/common\";\nimport * as i6 from \"./photo/photo.grid.gallery.component\";\nconst _c0 = [\"gridContainer\"];\nfunction GalleryGridComponent_app_gallery_grid_photo_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"app-gallery-grid-photo\", 2);\n    i0.ɵɵlistener(\"click\", function GalleryGridComponent_app_gallery_grid_photo_2_Template_app_gallery_grid_photo_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r4);\n      const gridPhoto_r2 = restoredCtx.$implicit;\n      const ctx_r3 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r3.photoClicked(gridPhoto_r2.media));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const gridPhoto_r2 = ctx.$implicit;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", gridPhoto_r2.renderWidth, \"px\")(\"height\", gridPhoto_r2.renderHeight, \"px\")(\"margin-left\", ctx_r1.IMAGE_MARGIN, \"px\")(\"margin-right\", ctx_r1.IMAGE_MARGIN, \"px\");\n    i0.ɵɵproperty(\"gridMedia\", gridPhoto_r2);\n  }\n}\nexport let GalleryGridComponent = /*#__PURE__*/(() => {\n  class GalleryGridComponent {\n    constructor(overlayService, changeDetector, queryService, router, galleryService, route) {\n      this.overlayService = overlayService;\n      this.changeDetector = changeDetector;\n      this.queryService = queryService;\n      this.router = router;\n      this.galleryService = galleryService;\n      this.route = route;\n      this.photosToRender = [];\n      this.containerWidth = 0;\n      this.screenHeight = 0;\n      this.IMAGE_MARGIN = 2;\n      this.isAfterViewInit = false;\n      this.subscriptions = {\n        route: null\n      };\n      this.delayedRenderUpToPhoto = null;\n      this.scrollListenerPhotos = [];\n      this.TARGET_COL_COUNT = 5;\n      this.MIN_ROW_COUNT = 2;\n      this.MAX_ROW_COUNT = 5;\n      this.onScrollFired = false;\n      this.helperTime = null;\n      this.renderedPhotoIndex = 0;\n      this.onChange = () => {\n        if (this.isAfterViewInit === false) {\n          return;\n        }\n        this.updateContainerDimensions();\n        this.mergeNewPhotos();\n        this.helperTime = window.setTimeout(() => {\n          this.renderPhotos();\n          if (this.delayedRenderUpToPhoto) {\n            this.renderUpToMedia(this.delayedRenderUpToPhoto);\n          }\n        }, 0);\n      };\n    }\n    ngOnChanges() {\n      this.onChange();\n    }\n    ngOnInit() {\n      this.subscriptions.route = this.route.queryParams.subscribe(params => {\n        if (params[QueryParams.gallery.photo] && params[QueryParams.gallery.photo] !== '') {\n          this.delayedRenderUpToPhoto = params[QueryParams.gallery.photo];\n          if (!this.media || this.media.length === 0) {\n            return;\n          }\n          this.renderUpToMedia(params[QueryParams.gallery.photo]);\n        }\n      });\n    }\n    ngOnDestroy() {\n      if (this.helperTime != null) {\n        clearTimeout(this.helperTime);\n      }\n      if (this.subscriptions.route !== null) {\n        this.subscriptions.route.unsubscribe();\n        this.subscriptions.route = null;\n      }\n    }\n    onResize() {\n      if (this.isAfterViewInit === false) {\n        return;\n      }\n      // render the same amount of images on resize\n      const renderedIndex = this.renderedPhotoIndex;\n      // do not rerender if container is not changes\n      if (this.updateContainerDimensions() === false) {\n        return;\n      }\n      this.renderPhotos(renderedIndex);\n    }\n    photoClicked(media) {\n      this.router.navigate([], {\n        queryParams: this.queryService.getParams(media)\n      });\n    }\n    ngAfterViewInit() {\n      this.lightbox.setGridPhotoQL(this.gridPhotoQL);\n      if (Config.Gallery.enableOnScrollThumbnailPrioritising === true) {\n        this.gridPhotoQL.changes.subscribe(() => {\n          this.scrollListenerPhotos = this.gridPhotoQL.filter(pc => pc.ScrollListener);\n        });\n      }\n      this.updateContainerDimensions();\n      this.clearRenderedPhotos();\n      this.helperTime = window.setTimeout(() => {\n        this.renderPhotos();\n      }, 0);\n      this.isAfterViewInit = true;\n    }\n    renderARow() {\n      if (this.renderedPhotoIndex >= this.media.length || this.containerWidth === 0) {\n        return null;\n      }\n      let maxRowHeight = this.getMaxRowHeight();\n      const minRowHeight = this.screenHeight / this.MAX_ROW_COUNT;\n      const photoRowBuilder = new GridRowBuilder(this.media, this.renderedPhotoIndex, this.IMAGE_MARGIN, this.containerWidth - this.overlayService.getPhantomScrollbarWidth());\n      photoRowBuilder.addPhotos(this.TARGET_COL_COUNT);\n      photoRowBuilder.adjustRowHeightBetween(minRowHeight, maxRowHeight);\n      // little trick: We don't want too big single images. But if a little extra height helps fit the row, its ok\n      if (photoRowBuilder.getPhotoRow().length > 1) {\n        maxRowHeight *= 1.2;\n      }\n      const rowHeight = Math.min(photoRowBuilder.calcRowHeight(), maxRowHeight);\n      const imageHeight = rowHeight - this.IMAGE_MARGIN * 2;\n      photoRowBuilder.getPhotoRow().forEach(photo => {\n        const imageWidth = imageHeight * MediaDTOUtils.calcAspectRatio(photo);\n        this.photosToRender.push(new GridMedia(photo, imageWidth, imageHeight, this.renderedPhotoIndex));\n      });\n      this.renderedPhotoIndex += photoRowBuilder.getPhotoRow().length;\n      return rowHeight;\n    }\n    onScroll() {\n      if (!this.onScrollFired && this.media && (\n      // should we trigger this at all?\n      this.renderedPhotoIndex < this.media.length || this.scrollListenerPhotos.length > 0)) {\n        window.requestAnimationFrame(() => {\n          this.renderPhotos();\n          if (Config.Gallery.enableOnScrollThumbnailPrioritising === true) {\n            this.scrollListenerPhotos.forEach(pc => {\n              pc.onScroll();\n            });\n            this.scrollListenerPhotos = this.scrollListenerPhotos.filter(pc => pc.ScrollListener);\n          }\n          this.onScrollFired = false;\n        });\n        this.onScrollFired = true;\n      }\n    }\n    getMaxRowHeight() {\n      return this.screenHeight / this.MIN_ROW_COUNT;\n    }\n    /**\r\n     * Makes sure that the photo with the given mediaString is visible on the screen\r\n     */\n    renderUpToMedia(mediaStringId) {\n      const index = this.media.findIndex(p => this.queryService.getMediaStringId(p) === mediaStringId);\n      if (index === -1) {\n        this.router.navigate([], {\n          queryParams: this.queryService.getParams()\n        });\n        return;\n      }\n      // Make sure that at leas one more photo is rendered\n      // It is possible that only the last few pixels of a photo is visible,\n      // so not required to render more, but the scrollbar does not trigger more photos to render\n      // (on ligthbox navigation)\n      while (this.renderedPhotoIndex - 1 < index + 1 && this.renderARow() !== null\n      // eslint-disable-next-line no-empty\n      ) {}\n    }\n    clearRenderedPhotos() {\n      this.photosToRender = [];\n      this.renderedPhotoIndex = 0;\n      this.changeDetector.detectChanges();\n    }\n    // TODO: This is deprecated,\n    // we do not post update galleries anymore since the preview member in the DriectoryDTO\n    mergeNewPhotos() {\n      // merge new data with old one\n      let lastSameIndex = 0;\n      let lastRowId = null;\n      let i = 0;\n      for (; i < this.media.length && i < this.photosToRender.length; ++i) {\n        // If a media changed the whole row has to be removed\n        if (this.photosToRender[i].rowId !== lastRowId) {\n          lastSameIndex = i;\n          lastRowId = this.photosToRender[i].rowId;\n        }\n        if (this.photosToRender[i].equals(this.media[i]) === false) {\n          break;\n        }\n      }\n      // if all the same\n      if (this.photosToRender.length > 0 && i === this.photosToRender.length && i === this.media.length && this.photosToRender[i - 1].equals(this.media[i - 1])) {\n        lastSameIndex = i;\n      }\n      if (lastSameIndex > 0) {\n        this.photosToRender.splice(lastSameIndex, this.photosToRender.length - lastSameIndex);\n        this.renderedPhotoIndex = lastSameIndex;\n      } else {\n        this.clearRenderedPhotos();\n      }\n    }\n    /**\r\n     * Returns true, if scroll is >= 70% to render more images.\r\n     * Or of onscroll rendering is off: return always to render all the images at once\r\n     * @param offset Add height to the client height (content is not yet added to the dom, but calculate with it)\r\n     * @returns boolean\r\n     */\n    shouldRenderMore(offset = 0) {\n      const bottomOffset = this.getMaxRowHeight() * 2;\n      return Config.Gallery.enableOnScrollRendering === false || PageHelper.ScrollY >= document.body.clientHeight + offset - window.innerHeight - bottomOffset || (document.body.clientHeight + offset) * 0.85 < window.innerHeight;\n    }\n    renderPhotos(numberOfPhotos = 0) {\n      if (!this.media) {\n        return;\n      }\n      if (this.containerWidth === 0 || this.renderedPhotoIndex >= this.media.length || !this.shouldRenderMore()) {\n        return;\n      }\n      let renderedContentHeight = 0;\n      while (this.renderedPhotoIndex < this.media.length && (this.shouldRenderMore(renderedContentHeight) === true || this.renderedPhotoIndex < numberOfPhotos)) {\n        const ret = this.renderARow();\n        if (ret === null) {\n          throw new Error('Grid media rendering failed');\n        }\n        renderedContentHeight += ret;\n      }\n    }\n    updateContainerDimensions() {\n      if (!this.gridContainer) {\n        return false;\n      }\n      const pre = PageHelper.isScrollYVisible();\n      PageHelper.showScrollY();\n      // if the width changed a bit or the height changed a lot\n      if (this.containerWidth !== this.gridContainer.nativeElement.clientWidth || this.screenHeight < window.innerHeight * 0.75 || this.screenHeight > window.innerHeight * 1.25) {\n        this.screenHeight = window.innerHeight;\n        this.containerWidth = this.gridContainer.nativeElement.clientWidth;\n        this.clearRenderedPhotos();\n        if (!pre) {\n          PageHelper.hideScrollY();\n        }\n        return true;\n      }\n      if (!pre) {\n        PageHelper.hideScrollY();\n      }\n      return false;\n    }\n  }\n  GalleryGridComponent.ɵfac = function GalleryGridComponent_Factory(t) {\n    return new (t || GalleryGridComponent)(i0.ɵɵdirectiveInject(i1.OverlayService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.QueryService), i0.ɵɵdirectiveInject(i3.Router), i0.ɵɵdirectiveInject(i4.ContentService), i0.ɵɵdirectiveInject(i3.ActivatedRoute));\n  };\n  GalleryGridComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: GalleryGridComponent,\n    selectors: [[\"app-gallery-grid\"]],\n    viewQuery: function GalleryGridComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(GalleryPhotoComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gridContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.gridPhotoQL = _t);\n      }\n    },\n    hostBindings: function GalleryGridComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"resize\", function GalleryGridComponent_resize_HostBindingHandler() {\n          return ctx.onResize();\n        }, false, i0.ɵɵresolveWindow)(\"scroll\", function GalleryGridComponent_scroll_HostBindingHandler() {\n          return ctx.onScroll();\n        }, false, i0.ɵɵresolveWindow);\n      }\n    },\n    inputs: {\n      lightbox: \"lightbox\",\n      media: \"media\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 1,\n    consts: [[\"gridContainer\", \"\"], [3, \"gridMedia\", \"width\", \"height\", \"margin-left\", \"margin-right\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"gridMedia\", \"click\"]],\n    template: function GalleryGridComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", null, 0);\n        i0.ɵɵtemplate(2, GalleryGridComponent_app_gallery_grid_photo_2_Template, 1, 9, \"app-gallery-grid-photo\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.photosToRender);\n      }\n    },\n    dependencies: [i5.NgForOf, i6.GalleryPhotoComponent],\n    styles: [\"div[_ngcontent-%COMP%]{line-height:normal;font-size:0}app-gallery-grid-photo[_ngcontent-%COMP%]{display:inline-block;cursor:pointer;margin:2px}\"]\n  });\n  return GalleryGridComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}