{"ast":null,"code":"import { HttpClient } from '@angular/common/http';\nimport { LoadingBarService } from '@ngx-loading-bar/core';\nimport { ErrorCodes } from '../../../../common/entities/Error';\nimport { Config } from '../../../../common/config/public/Config';\nimport { Utils } from '../../../../common/Utils';\nimport { CustomHeaders } from '../../../../common/CustomHeaders';\nimport { VersionService } from '../version.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"@ngx-loading-bar/core\";\nimport * as i3 from \"../version.service\";\nexport let NetworkService = /*#__PURE__*/(() => {\n  class NetworkService {\n    constructor(http, loadingBarService, versionService) {\n      this.http = http;\n      this.loadingBarService = loadingBarService;\n      this.versionService = versionService;\n      this.apiBaseUrl = Utils.concatUrls(Config.Server.urlBase, Config.Server.apiPath);\n      this.globalErrorHandlers = [];\n    }\n    static buildUrl(url, data) {\n      if (data) {\n        const keys = Object.getOwnPropertyNames(data);\n        if (keys.length > 0) {\n          url += '?';\n          for (let i = 0; i < keys.length; i++) {\n            url += keys[i] + '=' + data[keys[i]];\n            if (i < keys.length - 1) {\n              url += '&';\n            }\n          }\n        }\n      }\n      return url;\n    }\n    getXML(url) {\n      this.loadingBarService.useRef().start();\n      const process = res => {\n        this.loadingBarService.useRef().complete();\n        const parser = new DOMParser();\n        return parser.parseFromString(res, 'text/xml');\n      };\n      const err = error => {\n        this.loadingBarService.useRef().complete();\n        return this.handleError(error);\n      };\n      return this.http.get(this.apiBaseUrl + url, {\n        responseType: 'text'\n      }).toPromise().then(process).catch(err);\n    }\n    getText(url) {\n      this.loadingBarService.useRef().start();\n      const process = res => {\n        this.loadingBarService.useRef().complete();\n        return res;\n      };\n      const err = error => {\n        this.loadingBarService.useRef().complete();\n        return this.handleError(error);\n      };\n      return this.http.get(this.apiBaseUrl + url, {\n        responseType: 'text'\n      }).toPromise().then(process).catch(err);\n    }\n    postJson(url, data = {}) {\n      return this.callJson('post', url, data);\n    }\n    putJson(url, data = {}) {\n      return this.callJson('put', url, data);\n    }\n    getJson(url, query) {\n      return this.callJson('get', NetworkService.buildUrl(url, query));\n    }\n    deleteJson(url) {\n      return this.callJson('delete', url);\n    }\n    addGlobalErrorHandler(fn) {\n      this.globalErrorHandlers.push(fn);\n    }\n    callJson(method, url, data = {}) {\n      const body = data;\n      this.loadingBarService.useRef().start();\n      const process = res => {\n        this.loadingBarService.useRef().complete();\n        const msg = res.body;\n        if (res.headers.has(CustomHeaders.dataVersion)) {\n          this.versionService.onNewVersion(res.headers.get(CustomHeaders.dataVersion));\n        }\n        if (msg.error) {\n          if (msg.error.code) {\n            msg.error.title = ErrorCodes[msg.error.code];\n          }\n          throw msg.error;\n        }\n        return msg.result;\n      };\n      const err = error => {\n        this.loadingBarService.useRef().complete();\n        return this.handleError(error);\n      };\n      switch (method) {\n        case 'get':\n          return this.http.get(this.apiBaseUrl + url, {\n            observe: 'response'\n          }).toPromise().then(process).catch(err);\n        case 'delete':\n          return this.http.delete(this.apiBaseUrl + url, {\n            observe: 'response'\n          }).toPromise().then(process).catch(err);\n        case 'post':\n          return this.http.post(this.apiBaseUrl + url, body, {\n            observe: 'response'\n          }).toPromise().then(process).catch(err);\n        case 'put':\n          return this.http.put(this.apiBaseUrl + url, body, {\n            observe: 'response'\n          }).toPromise().then(process).catch(err);\n        default:\n          throw new Error('Unknown method');\n      }\n    }\n    handleError(error) {\n      if (typeof error.code !== 'undefined') {\n        for (const item of this.globalErrorHandlers) {\n          if (item(error) === true) {\n            return;\n          }\n        }\n        return Promise.reject(error);\n      }\n      // instead of just logging it to the console\n      console.error('error:', error);\n      return Promise.reject(error.message || error || 'Server error');\n    }\n  }\n  NetworkService.ɵfac = function NetworkService_Factory(t) {\n    return new (t || NetworkService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.LoadingBarService), i0.ɵɵinject(i3.VersionService));\n  };\n  NetworkService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: NetworkService,\n    factory: NetworkService.ɵfac\n  });\n  return NetworkService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}