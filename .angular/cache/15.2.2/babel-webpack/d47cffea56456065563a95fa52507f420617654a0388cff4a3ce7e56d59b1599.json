{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConfigClassBase = void 0;\nconst tslib_1 = require(\"tslib\");\nconst ConstraintError_1 = require(\"../../exceptions/ConstraintError\");\nconst Utils_1 = require(\"../../../Utils\");\nconst Loader_1 = require(\"../../../Loader\");\nfunction ConfigClassBase(constructorFunction, options) {\n  if (typeof options === 'undefined') {\n    throw new Error('options not set');\n  }\n  return class ConfigClassBaseType extends constructorFunction {\n    constructor(...args) {\n      super(...args);\n      this.__propPath = '';\n      this.__created = false;\n      this.__prototype = constructorFunction.prototype;\n      const tmpState = this.__state || {};\n      this.__state = {};\n      for (const key of Object.keys(tmpState)) {\n        if (typeof tmpState[key] === 'undefined') {\n          continue;\n        }\n        this.__state[key] = Object.assign({}, tmpState[key]);\n      }\n      // Only add tags to the current class prototype\n      if (options.tags) {\n        for (const key of Object.keys(this.__prototype)) {\n          if (typeof this.__state[key] === 'undefined') {\n            continue;\n          }\n          this.__state[key].tags = this.__state[key].tags || {};\n          Object.assign(this.__state[key].tags, options.tags);\n        }\n      }\n      for (const key of Object.keys(this.__state)) {\n        if (typeof this.__state[key].value === 'undefined') {\n          continue;\n        }\n        this.__state[key].default = this.__state[key].value;\n        if (this.__state[key].value) {\n          if (typeof this.__state[key].value.__defaults !== 'undefined') {\n            this.__state[key].default = this.__state[key].value.__defaults;\n          } else {\n            // defaults should only be plain jsons, no config classes\n            if (this.__state[key].value.toJSON) {\n              this.__state[key].default = this.__state[key].value.toJSON();\n            } else {\n              this.__state[key].default = JSON.parse(JSON.stringify(this.__state[key].value));\n            }\n          }\n        }\n      }\n      this.__created = true;\n    }\n    get __options() {\n      return options;\n    }\n    get __defaults() {\n      const ret = {};\n      for (const key of Object.keys(this.__state)) {\n        if (typeof this.__state[key].default === 'undefined') {\n          continue;\n        }\n        ret[key] = this.__state[key].default;\n      }\n      return ret;\n    }\n    static isConfigClassBaseCtor(ctor) {\n      return ctor && ctor.prototype && typeof ctor.prototype.__loadJSONObject === 'function' && typeof ctor.prototype.toJSON === 'function';\n    }\n    static isConfigClassBase(value) {\n      return value && typeof value.__loadJSONObject === 'function' && typeof value.toJSON === 'function';\n    }\n    __getNavigatableState() {\n      const ret = {};\n      for (const key of Object.keys(this.__state)) {\n        if (this.__state[key].value && this.__state[key].value.__getNavigatableState) {\n          Object.defineProperty(ret, key, {\n            get: () => this.__state[key].value.__getNavigatableState(),\n            enumerable: true,\n            configurable: true\n          });\n          continue;\n        }\n        ret[key] = this.__state[key];\n      }\n      return ret;\n    }\n    __loadStateJSONObject(sourceObject) {\n      if (sourceObject === null || typeof sourceObject === 'undefined') {\n        return;\n      }\n      Object.keys(sourceObject).forEach(key => {\n        if (typeof this.__state[key] === 'undefined') {\n          return;\n        }\n        if (this.__state[key].value && typeof this.__state[key].value.__loadStateJSONObject !== 'undefined') {\n          this[key].__loadStateJSONObject(sourceObject[key]);\n          return;\n        }\n        if (sourceObject[key].readonly) {\n          this.__state[key].readonly = sourceObject[key].readonly;\n        }\n        if (sourceObject[key].default) {\n          this.__state[key].default = sourceObject[key].default;\n        }\n        if (sourceObject[key].volatile) {\n          this.__state[key].volatile = sourceObject[key].volatile;\n        }\n      });\n    }\n    __loadDefaultsJSONObject(sourceObject) {\n      if (sourceObject === null || typeof sourceObject === 'undefined') {\n        return;\n      }\n      Object.keys(sourceObject).forEach(key => {\n        if (typeof this.__state[key] === 'undefined' || typeof sourceObject[key] === 'undefined') {\n          return;\n        }\n        if (this.__state[key].isConfigType) {\n          if (this.__state[key].default && typeof this.__state[key].default.__loadDefaultsJSONObject !== 'undefined') {\n            this.__state[key].default.__loadDefaultsJSONObject(sourceObject[key]);\n          }\n          if (typeof this.__state[key].value !== 'undefined') {\n            this[key].__loadDefaultsJSONObject(sourceObject[key]);\n          }\n          Loader_1.Loader.loadObject(this.__state[key].default, sourceObject[key]);\n          return;\n        }\n        this.__state[key].default = sourceObject[key];\n      });\n    }\n    __loadJSONObject(sourceObject, setToReadonly = false, skipValidation = false) {\n      let changed = false;\n      if (sourceObject === null || typeof sourceObject === 'undefined') {\n        return false;\n      }\n      Object.keys(sourceObject).forEach(key => {\n        if (typeof this.__state[key] === 'undefined') {\n          return;\n        }\n        const set = () => {\n          if (skipValidation) {\n            this.__state[key].value = this.__validateType(key, sourceObject[key]);\n          } else {\n            this[key] = sourceObject[key];\n          }\n          changed = true;\n          if (setToReadonly === true && options.disableAutoReadonly !== true) {\n            this.__state[key].readonly = true;\n          }\n        };\n        if (this.__state[key].type === 'array') {\n          if (this.__state[key].value !== sourceObject[key]) {\n            try {\n              if (typeof sourceObject[key] === 'string' && Array.isArray(JSON.parse(sourceObject[key]))) {\n                sourceObject[key] = JSON.parse(sourceObject[key]);\n              }\n            } catch (e) {}\n            set();\n          }\n        } else if (this.__state[key].value && typeof this.__state[key].value.__loadJSONObject !== 'undefined') {\n          changed = this[key].__loadJSONObject(sourceObject[key], setToReadonly, skipValidation) || changed;\n        } else if (this.__state[key].type === 'object') {\n          set();\n        } else if (this.__state[key].value !== sourceObject[key]) {\n          this[key] = sourceObject[key];\n          set();\n        }\n      });\n      return changed;\n    }\n    __getENVAliases() {\n      let ret = [];\n      for (const key of Object.keys(this.__state)) {\n        if (typeof this.__state[key].envAlias !== 'undefined') {\n          ret.push({\n            key: this.__getFulName(key).replace(new RegExp('\\\\.', 'gm'), '-'),\n            alias: this.__state[key].envAlias\n          });\n        }\n        if (this.__state[key].value !== null && typeof this.__state[key].value !== 'undefined' && typeof this.__state[key].value.__getENVAliases !== 'undefined') {\n          ret = ret.concat(this.__state[key].value.__getENVAliases());\n        }\n      }\n      return ret;\n    }\n    __setParentConfig(propertyPath, rootConf) {\n      this.__rootConfig = rootConf;\n      this.__propPath = propertyPath;\n      for (const key of Object.keys(this.__state)) {\n        if (this.__state[key].value === null || typeof this.__state[key].value === 'undefined' || typeof this.__state[key].value.__setParentConfig === 'undefined') {\n          continue;\n        }\n        const propPath = this.__propPath.length > 0 ? this.__propPath + '.' + key : key;\n        this.__state[key].value.__setParentConfig(propPath, this.__rootConfig);\n      }\n    }\n    __validateAll(exceptionStack) {\n      for (const key of Object.keys(this.__state)) {\n        this.__validate(key, this.__state[key].value, this.__state[key], exceptionStack);\n        if (this.__state[key].value && this.__state[key].value.__validateAll) {\n          this.__state[key].value.__validateAll(exceptionStack);\n        }\n      }\n    }\n    __setAndValidateFromRoot(property, newValue) {\n      // during setting default value, this variable is not exist yet\n      if (this.__state[property].value === newValue) {\n        return;\n      }\n      // skip readonly if we are setting the default value\n      if (this.__state[property].readonly === true && this.__created === true && options.softReadonly !== true) {\n        throw new Error(property + ' is readonly');\n      }\n      this.__state[property].value = newValue;\n      if (this.__rootConfig) {\n        // while sub config default value set, the root conf is not available yet.\n        if (typeof this.__state[property].onNewValue !== 'undefined') {\n          this.__state[property].onNewValue(this.__state[property].value, this.__rootConfig);\n        }\n        const exceptionStack = [];\n        this.__rootConfig.__validateAll(exceptionStack);\n        if (exceptionStack.length > 0) {\n          throw new ConstraintError_1.ConstraintError(exceptionStack.join(', '));\n        }\n      }\n    }\n    __validate(property, newValue, _typeState, exceptionStack) {\n      if (typeof this.__rootConfig === 'undefined') {\n        return newValue;\n      }\n      newValue = this.__validateType(property, newValue, _typeState);\n      this.__validateConstrains(property, newValue, exceptionStack);\n      return newValue;\n    }\n    __validateConstrains(property, newValue, exceptionStack) {\n      if (typeof this.__state[property].constraint !== 'undefined') {\n        if (this.__state[property].constraint.assert(newValue, this.__rootConfig) !== true) {\n          let exStr = this.__state[property].constraint.assertReason;\n          if (typeof this.__state[property].constraint.fallBackValue !== 'undefined') {\n            this.__setAndValidateFromRoot(property, this.__state[property].constraint.fallBackValue);\n            if (!exStr) {\n              exStr = 'Constraint failed for ' + property + ' falling back to value: ' + this.__state[property].constraint.fallBackValue;\n            }\n          }\n          if (!exStr) {\n            exStr = 'Constraint failed for ' + property;\n          }\n          if (exceptionStack) {\n            exceptionStack.push(exStr);\n          } else {\n            throw new ConstraintError_1.ConstraintError(exStr);\n          }\n        }\n      }\n    }\n    /**\r\n     * Checks if the value is valid with the given type.\r\n     * Makes basic casting and conversion\r\n     * @param property\r\n     * @param newValue\r\n     * @param _typeState\r\n     * @private\r\n     */\n    __validateType(property, newValue, _typeState) {\n      if (typeof newValue === 'undefined' || newValue == null) {\n        return newValue;\n      }\n      const propState = this.__state[property];\n      const type = typeof _typeState !== 'undefined' ? _typeState.type : propState.typeBuilder ? propState.typeBuilder(newValue, this.__rootConfig) : propState.type;\n      const isEnumType = typeof _typeState !== 'undefined' ? _typeState.isEnumType : propState.isEnumType;\n      const isConfigType = typeof _typeState !== 'undefined' ? _typeState.isConfigType : propState.isConfigType;\n      const strValue = String(newValue);\n      let floatValue = NaN;\n      if (parseFloat(strValue).toString() === strValue) {\n        floatValue = parseFloat(strValue);\n      }\n      let intValue = NaN;\n      if (parseInt(strValue, 10).toString() === strValue) {\n        intValue = parseInt(strValue, 10);\n      }\n      const checkRange = () => {\n        if (typeof propState.min !== 'undefined' && floatValue < propState.min) {\n          throw new Error(newValue + ' should be greater than ' + propState.min);\n        }\n        if (typeof propState.max !== 'undefined' && floatValue > propState.max) {\n          throw new Error(newValue + ' should be less than ' + propState.max);\n        }\n      };\n      switch (type) {\n        case 'string':\n          return strValue;\n        case 'float':\n          checkRange();\n          return floatValue;\n        case 'date':\n          if (typeof intValue === 'undefined' && isNaN(Date.parse(newValue))) {\n            throw new TypeError(this.__getFulName(property) + ' should be a Date, got:' + newValue);\n          }\n          return new Date(newValue);\n        case 'boolean':\n          if (strValue.toLowerCase() === 'false' || newValue === false) {\n            return false;\n          }\n          if (strValue.toLowerCase() === 'true' || newValue === true) {\n            return true;\n          }\n          throw new TypeError(this.__getFulName(property) + ' should be a boolean');\n        case 'array':\n          if (!Array.isArray(newValue)) {\n            throw new TypeError(this.__getFulName(property) + ' should be an array');\n          }\n          if (propState.arrayType !== 'array') {\n            const tmpNewValue = [];\n            for (let i = 0; i < newValue.length; ++i) {\n              const t = propState.arrayTypeBuilder ? propState.arrayTypeBuilder(newValue[i], this.__rootConfig) : propState.arrayType ? propState.arrayType : null;\n              tmpNewValue[i] = this.__validate(property, newValue[i], {\n                type: t,\n                isEnumType: propState.isEnumArrayType,\n                isConfigType: propState.isConfigArrayType\n              });\n            }\n            return tmpNewValue;\n          }\n          return newValue;\n        case 'integer':\n          checkRange();\n          if (intValue !== floatValue) {\n            throw new TypeError('Value should be an integer, got: ' + newValue);\n          }\n          return intValue;\n        case 'ratio':\n          checkRange();\n          if (floatValue < 0 || floatValue > 1) {\n            throw new TypeError('Value should be an ratio, got: ' + newValue);\n          }\n          return floatValue;\n        case 'unsignedInt':\n          checkRange();\n          if (intValue !== floatValue || intValue < 0) {\n            throw new TypeError('Value should be an unsigned integer, got: ' + newValue);\n          }\n          return intValue;\n        case 'positiveFloat':\n          checkRange();\n          if (floatValue < 0) {\n            throw new TypeError('Value should be an positive float, got: ' + newValue);\n          }\n          return floatValue;\n      }\n      if (isEnumType === true) {\n        if (Number.isInteger(intValue) && typeof type[intValue] !== 'undefined') {\n          return intValue;\n        }\n        if (typeof newValue === 'string' && typeof type[strValue] === 'number') {\n          return type[strValue];\n        }\n        throw new TypeError(this.__getFulName(property) + ' should be an Enum from values: ' + Object.keys(type) + ', got: ' + newValue);\n      }\n      if (isConfigType === true && propState.value && typeof propState.value.__loadJSONObject !== 'undefined') {\n        propState.value.__loadJSONObject(newValue);\n        return propState.value;\n      }\n      if (isConfigType === true && !ConfigClassBaseType.isConfigClassBase(newValue)) {\n        const o = new type();\n        const propPath = this.__propPath.length > 0 ? this.__propPath + '.' + property : property;\n        o.__setParentConfig(propPath, this.__rootConfig);\n        o.__loadJSONObject(newValue);\n        return o;\n      }\n      return newValue;\n    }\n    /**\r\n     * Clones its state to the to object\r\n     * @param to config object to clone its state to\r\n     */\n    __cloneTo(to) {\n      const configJson = this.toJSON({\n        attachState: true,\n        attachDescription: false,\n        attachVolatile: true,\n        enumsAsString: false\n      });\n      // postpone readonly loading\n      const __state = configJson.__state;\n      delete configJson.__state;\n      to.__loadJSONObject(configJson, false, true);\n      to.__loadStateJSONObject(__state);\n    }\n    toJSON(opt) {\n      opt = JSON.parse(JSON.stringify(typeof opt === 'object' ? opt : options));\n      const ret = {};\n      // Attach __state\n      if (opt.attachState === true) {\n        ret['__state'] = {};\n        const loadState = (from, to) => {\n          for (const key of Object.keys(from.__state)) {\n            if (typeof from.__state[key] === 'undefined') {\n              continue;\n            }\n            to[key] = {};\n            if (from.__state[key].value && typeof from.__state[key].value.__state !== 'undefined') {\n              loadState(from.__state[key].value, to[key]);\n            } else if (from.__state[key].default && typeof from.__state[key].default.__state !== 'undefined') {\n              loadState(from.__state[key].default, to[key]);\n            } else {\n              const _a = from.__state[key],\n                {\n                  value,\n                  type,\n                  arrayType,\n                  typeBuilder,\n                  arrayTypeBuilder,\n                  onNewValue,\n                  isConfigType,\n                  isEnumType,\n                  isEnumArrayType,\n                  isConfigArrayType,\n                  constraint,\n                  envAlias,\n                  description\n                } = _a,\n                noValue = tslib_1.__rest(_a, [\"value\", \"type\", \"arrayType\", \"typeBuilder\", \"arrayTypeBuilder\", \"onNewValue\", \"isConfigType\", \"isEnumType\", \"isEnumArrayType\", \"isConfigArrayType\", \"constraint\", \"envAlias\", \"description\"]);\n              to[key] = noValue;\n            }\n          }\n        };\n        loadState(this, ret['__state']);\n      }\n      opt.attachState = false; // do not cascade defaults, root already knows it.\n      for (const key of Object.keys(this.__state)) {\n        if (this.__state[key].volatile === true && opt.attachVolatile !== true || typeof this.__state[key].value === 'undefined' || opt.skipTags && this.__state[key].tags && Object.keys(opt.skipTags).findIndex(k => opt.skipTags[k] === this.__state[key].tags[k]) !== -1 || opt.keepTags && this.__state[key].tags && Object.keys(opt.keepTags).findIndex(k => opt.keepTags[k] === this.__state[key].tags[k]) === -1) {\n          continue;\n        }\n        if (opt.attachDescription === true && typeof this.__state[key].description !== 'undefined') {\n          ret['//[' + key + ']'] = this.__state[key].description;\n        }\n        // if ConfigClass type?\n        if (this.__state[key].isConfigType === true && this.__state[key].value) {\n          ret[key] = this.__state[key].value.toJSON(opt);\n          continue;\n        }\n        if (Array.isArray(this.__state[key].value)) {\n          ret[key] = this.__state[key].value.map(v => {\n            if (this.__state[key].isConfigArrayType === true) {\n              return v.toJSON(opt);\n            }\n            return v;\n          });\n          continue;\n        }\n        if (opt.enumsAsString === true && Utils_1.Utils.isEnum(this.__state[key].type)) {\n          ret[key] = this.__state[key].type[this.__state[key].value];\n        } else {\n          ret[key] = this.__state[key].value;\n        }\n      }\n      return ret;\n    }\n    __getFulName(property, separator = '.') {\n      return (this.__propPath ? this.__propPath + '.' + property : property).replace(new RegExp('\\\\.', 'gm'), separator);\n    }\n    __getLongestOptionName(printENVAlias) {\n      let max = 0;\n      for (const key of Object.keys(this.__state)) {\n        const state = this.__state[key];\n        const value = this.__state[key].value;\n        if (state.volatile === true) {\n          continue;\n        }\n        max = Math.max(max, this.__getFulName(key).length);\n        if (printENVAlias && typeof state.envAlias !== 'undefined') {\n          max = Math.max(max, state.envAlias.length);\n        }\n        if (value && typeof value.__getLongestOptionName === 'function') {\n          max = Math.max(max, value.__getLongestOptionName());\n        }\n      }\n      return max;\n    }\n    ___printOption(prefix, printENVAlias, longestName = 0) {\n      let ret = '';\n      const padding = '  ';\n      // get longest switch name\n      longestName = Math.max(longestName, this.__getLongestOptionName(printENVAlias));\n      for (const key of Object.keys(this.__state)) {\n        const state = this.__state[key];\n        const value = this.__state[key].value;\n        if (state.volatile === true) {\n          continue;\n        }\n        if (value && typeof value.___printOption === 'function') {\n          ret += value.___printOption(prefix, printENVAlias, longestName);\n          continue;\n        }\n        let def = this.__defaults[key];\n        if (Utils_1.Utils.isEnum(this.__state[key].type) && typeof def !== 'undefined') {\n          def = this.__state[key].type[this.__defaults[key]];\n        }\n        if (typeof def === 'string') {\n          def = '\\'' + def + '\\'';\n        }\n        if (typeof def === 'object') {\n          def = JSON.stringify(def);\n        }\n        ret += padding + prefix + this.__getFulName(key, '-').padEnd(longestName + prefix.length + padding.length);\n        if (this.__state[key].description) {\n          ret += this.__state[key].description;\n        }\n        if (typeof def !== 'undefined') {\n          ret += ' (default: ' + def + ')';\n        }\n        ret += '\\n';\n        if (typeof this.__state[key].envAlias !== 'undefined' && printENVAlias === true) {\n          ret += padding + this.__state[key].envAlias.padEnd(longestName + prefix.length + padding.length) + ' same as ' + prefix + this.__getFulName(key, '-') + '\\n';\n        }\n      }\n      return ret;\n    }\n  };\n}\nexports.ConfigClassBase = ConfigClassBase;\n//# sourceMappingURL=ConfigClassBase.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}