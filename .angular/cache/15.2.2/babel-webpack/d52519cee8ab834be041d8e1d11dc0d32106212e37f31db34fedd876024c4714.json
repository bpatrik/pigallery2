{"ast":null,"code":"export class Utils {\n  static GUID() {\n    const s4 = () => Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    return s4() + s4() + '-' + s4() + s4();\n  }\n  static chunkArrays(arr, chunkSize) {\n    const R = [];\n    for (let i = 0; i < arr.length; i += chunkSize) {\n      R.push(arr.slice(i, i + chunkSize));\n    }\n    return R;\n  }\n  static wait(time) {\n    return new Promise(resolve => {\n      setTimeout(resolve, time);\n    });\n  }\n  static removeNullOrEmptyObj(obj) {\n    if (typeof obj !== 'object' || obj == null) {\n      return obj;\n    }\n    const keys = Object.keys(obj);\n    for (const key of keys) {\n      if (obj[key] !== null && typeof obj[key] === 'object') {\n        if (Utils.removeNullOrEmptyObj(obj[key])) {\n          if (Object.keys(obj[key]).length === 0) {\n            delete obj[key];\n          }\n        }\n      } else if (obj[key] === null) {\n        delete obj[key];\n      }\n    }\n    return obj;\n  }\n  static clone(object) {\n    return JSON.parse(JSON.stringify(object));\n  }\n  static shallowClone(object) {\n    const c = {};\n    for (const e of Object.entries(object)) {\n      c[e[0]] = e[1];\n    }\n    return c;\n  }\n  static zeroPrefix(value, length) {\n    const ret = '00000' + value;\n    return ret.substr(ret.length - length);\n  }\n  /**\r\n   * Checks if the two input (let them be objects or arrays or just primitives) are equal\r\n   */\n  static equalsFilter(object, filter, skipProp = []) {\n    if (typeof filter !== 'object' || filter == null) {\n      return object === filter;\n    }\n    if (!object) {\n      return false;\n    }\n    if (Array.isArray(object) && object.length !== filter.length) {\n      return false;\n    }\n    const keys = Object.keys(filter);\n    for (const key of keys) {\n      if (skipProp.includes(key)) {\n        continue;\n      }\n      if (typeof filter[key] === 'object') {\n        if (Utils.equalsFilter(object[key], filter[key], skipProp) === false) {\n          return false;\n        }\n      } else if (object[key] !== filter[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static renderDataSize(size) {\n    const postFixes = ['B', 'KB', 'MB', 'GB', 'TB'];\n    let index = 0;\n    while (size > 1000 && index < postFixes.length - 1) {\n      size /= 1000;\n      index++;\n    }\n    return size.toFixed(2) + postFixes[index];\n  }\n  static getUnique(arr) {\n    return arr.filter((value, index, arr) => arr.indexOf(value) === index);\n  }\n  static createRange(from, to) {\n    const arr = new Array(to - from + 1);\n    let c = to - from + 1;\n    while (c--) {\n      arr[c] = to--;\n    }\n    return arr;\n  }\n  static canonizePath(path) {\n    return path.replace(new RegExp('\\\\\\\\', 'g'), '/').replace(new RegExp('/+', 'g'), '/');\n  }\n  static concatUrls(...args) {\n    let url = '';\n    for (const item of args) {\n      if (item === '' || typeof item === 'undefined') {\n        continue;\n      }\n      const part = item.replace(new RegExp('\\\\\\\\', 'g'), '/');\n      if (part === '/' || part === './') {\n        continue;\n      }\n      url += part + '/';\n    }\n    url = url.replace(/(https?:\\/\\/)|(\\/){2,}/g, '$1$2');\n    if (url.trim() === '') {\n      url = './';\n    }\n    return url.substring(0, url.length - 1);\n  }\n  static updateKeys(targetObject, sourceObject) {\n    Object.keys(sourceObject).forEach(key => {\n      if (typeof targetObject[key] === 'undefined') {\n        return;\n      }\n      if (typeof targetObject[key] === 'object') {\n        Utils.updateKeys(targetObject[key], sourceObject[key]);\n      } else {\n        targetObject[key] = sourceObject[key];\n      }\n    });\n  }\n  static setKeys(targetObject, sourceObject) {\n    Object.keys(sourceObject).forEach(key => {\n      if (typeof targetObject[key] === 'object') {\n        Utils.setKeys(targetObject[key], sourceObject[key]);\n      } else {\n        targetObject[key] = sourceObject[key];\n      }\n    });\n  }\n  static setKeysForced(targetObject, sourceObject) {\n    Object.keys(sourceObject).forEach(key => {\n      if (typeof sourceObject[key] === 'object') {\n        if (typeof targetObject[key] === 'undefined') {\n          targetObject[key] = {};\n        }\n        Utils.setKeysForced(targetObject[key], sourceObject[key]);\n      } else {\n        targetObject[key] = sourceObject[key];\n      }\n    });\n  }\n  static enumToArray(EnumType) {\n    const arr = [];\n    for (const enumMember in EnumType) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (!EnumType.hasOwnProperty(enumMember)) {\n        continue;\n      }\n      const key = parseInt(enumMember, 10);\n      if (key >= 0) {\n        arr.push({\n          key,\n          value: EnumType[enumMember]\n        });\n      }\n    }\n    return arr;\n  }\n  static findClosest(num, arr) {\n    let curr = arr[0];\n    let diff = Math.abs(num - curr);\n    arr.forEach(value => {\n      const newDiff = Math.abs(num - value);\n      if (newDiff < diff) {\n        diff = newDiff;\n        curr = value;\n      }\n    });\n    return curr;\n  }\n  static findClosestinSorted(num, arr) {\n    let curr = arr[0];\n    let diff = Math.abs(num - curr);\n    for (const item of arr) {\n      const newDiff = Math.abs(num - item);\n      if (newDiff > diff) {\n        break;\n      }\n      diff = newDiff;\n      curr = item;\n    }\n    return curr;\n  }\n  static isUInt32(value, max = 4294967295) {\n    value = parseInt('' + value, 10);\n    return !isNaN(value) && value >= 0 && value <= max;\n  }\n  static isInt32(value) {\n    value = parseFloat('' + value);\n    return !isNaN(value) && value >= -2147483648 && value <= 2147483647;\n  }\n  static isFloat32(value) {\n    const E = Math.pow(10, 38);\n    const nE = Math.pow(10, -38);\n    return !isNaN(value) && (value >= -3.402823466 * E && value <= -1.175494351 * nE || value <= 3.402823466 * E && value >= 1.175494351 * nE);\n  }\n  static getAnyX(num, arr, start = 0) {\n    if (num <= 0 || num > arr.length || start >= arr.length) {\n      return [];\n    }\n    if (num <= 1) {\n      return arr.slice(start).map(e => [e]);\n    }\n    if (num === arr.length - start) {\n      return [arr.slice(start)];\n    }\n    const ret = [];\n    for (let i = start; i < arr.length; ++i) {\n      Utils.getAnyX(num - 1, arr, i + 1).forEach(a => {\n        a.push(arr[i]);\n        ret.push(a);\n      });\n    }\n    return ret;\n  }\n}\nexport class LRU {\n  constructor(size) {\n    this.size = size;\n    this.data = {};\n  }\n  set(key, value) {\n    this.data[key] = {\n      usage: Date.now(),\n      value\n    };\n    if (Object.keys(this.data).length > this.size) {\n      let oldestK = key;\n      let oldest = this.data[oldestK].usage;\n      for (const k in this.data) {\n        if (this.data[k].usage < oldest) {\n          oldestK = k;\n          oldest = this.data[oldestK].usage;\n        }\n      }\n      delete this.data[oldestK];\n    }\n  }\n  get(key) {\n    if (!this.data[key]) {\n      return;\n    }\n    return this.data[key].value;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}